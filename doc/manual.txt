



PBC Library Manual


Ben Lynn

Copyright Â© 2006 Ben Lynn
-------------------------------------------------------------------------------


  Preface

  1._Overview

  2._Installing_PBC

  3._PBC_Basics


        Headers_and_Libraries

        Types

        Function_Classes

        Conventions


  4._Pairing_Functions


        Initializing_Pairings

        Other_Pairing_Functions


  5._Element_Functions


        Initializing_Elements

        Assigning_Elements

        Converting_Elements

        Element_Arithmetic

        Exponentiating_Elements

        Comparing_Elements

        I/O_of_Elements

        Random_Elements

        Element_Import/Export


  6._Randomness_Functions

  7._Param_Functions


        Type_A


  8._Tutorial


        BLS_Signatures

        Import/Export


  9._PBC_Internals


        Justifying_Design_Decisions

        Internal_Randomness

        Type_A_Internals


  A._Contributors


Preface

This manual describes how to install and use the PBC pairing-based cryptography
library, version 0.3.3. It is modeled on the GMP manual.

Chapter 1. Overview

The PBC library is a C library designed to make it easy to implement pairing-
based cryptosystems. It provides an abstract interface to a cyclic group with a
bilinear pairing, and the programmer does not need to worry about, or even know
about elliptic curves.
It is built on top of GMP, another C library which performs arbitrary precision
arithmetic on integers, rationals and floats with strong emphasis on
portability and speed.
The PBC library homepage: http://rooster.stanford.edu/~ben/pbc/
The GMP library homepage: http://www.swox.com/gmp/

Chapter 2. Installing PBC

The PBC library needs the GMP library, which can be found at http://
www.swox.com/gmp/
This build system has been tested and works on Linux and Mac OS X with a fink
installation. You may need to specify paths via LDFLAGS and CPPFLAGS if
libraries are located in places other than the default assumed in configure.ac.
See ./configure --help for more information.

  ./configure
  make
  make install

PBC uses some GNU C extensions, notably nested functions, and also printf
extensions. The latter may be safely commented out as it is only used in
demonstration programs.

Chapter 3. PBC Basics

This chapter gives a high-level view of the library, and explains various
design choices and conventions.

Headers and Libraries

Programs using the PBC library should include the file pbc.h:

  #include <pbc.h>

and linked against the PBC library, e.g.

  gcc program.c -L. -lpbc

The file pbc.h includes gmp.h thus all GMP functions are available.
The PBC signatures library is currently bundled with PBC. Documentation will
eventually written for it, but for now look at sample signature programs in the
test directory.

Types

Since the PBC library is built on top of GMP, the GMP types are available. PBC
types are similar to GMP types. The following example is paraphrased from an
example in the GMP manual, and shows how to declare the PBC data type
element_t.

      element_t sum;

      struct foo { element_t x, y; };

      element_t vec[20];

The pairing_t data type holds bilinear pairing parameter information. There are
other data types but for many pairing-based cryptography applications they are
only needed internally.
Examples of other data types defined by PBC are field_t for rings and fields
and mpc_t for complex arbitrary precision floats.

Function Classes

PBC contains several classes of functions.

  1. Functions for dealing with bilinear pairing parameters begin with
     pairing_.
  2. Functions for operating on elements of groups, rings and fields begin with
     element_.
  3. Functions that generate pairing parameters, that is, find elliptic curves
     where efficiently computable bilinear pairings exist. The sample
     parameters bundled are adequate for many cryptosystems, but there may be a
     need to generate more.
  4. Miscellaneous functions, such as ones controlling how random bits are
     generated.


Conventions

PBC follows GMP in several respects:

  1. Output arguments generally precede input arguments.
  2. The same variable can be used as input and output in one call.
  3. Before a variable may be used it must be initialized exactly once. When no
     longer needed it must be cleared. For efficiency, unnecessary
     initializating and clearing should be avoided.
  4. PBC variables ending with _t behave the same as GMP variables in function
     calls, that is effectively as call-by references. In other words, as in
     GMP, if a function that modifies an input variable, that variable remains
     modified when control return is returned to the caller.
  5. Variables automatically allocate memory via malloc() when needed. Unlike
     GMP, there is no simple way to change the memory allocator yet.
  6. The element_t type is small (but certain other types are not).
  7. PBC functions are mostly reentrant.

On the other hand, element_t is more complex than GMP types in that the same
data type is used for elements of different algebraic structures, such as
elliptic curve groups, polynomial rings and finite fields. Many functions
assume the inputs come from the same algebraic structure and trouble can arise
if for example one attempts to add a polynomial to a point on an elliptic
curve.

Chapter 4. Pairing Functions

An application will most likely need to instantiate a bilinear pairing before
performing any other PBC operations.
Parameters for various pairings are bundled with PBC and should be suitable for
cryptographic use. Most programs will probably want to start by initializing a
pairing by reading a set of pairing parameters.
Particular instantiations of bilinear pairings are stored in the data type
pairing_t. Functions that operate on them start with pairing_.
Pairings involve three groups of prime order. The PBC library labels them G1,
G2, and GT, and labels the order r. The pairing is a bilinear map that takes
two elements as input, one from G1 and one from G2, and outputs an element of
GT.

Initializing Pairings

The only way to initialize a pairing is to provide pairing parameters to a
pairing_t variable using one of the functions beginning with pairing_init_inp_.
For example,

  {
      pairing_t pairing;

      pairing_init_inp_str(pairing, stdin);
  }

will initialize pairing with parameters are fed to the program on standard
input.


  void pairing_init_inp_generic(pairing_t pairing, fetch_ops_t *fops, void
  *ctx)
      TODO

  void pairing_init_inp_buf(pairing_t pairing, const char *buf, size_t len)
      Read in pairing parameters from array of characters buf of length len and
      use them to initialize pairing.

  void pairing_init_inp_str(pairing_t pairing, FILE *stream)
      Read in pairing parameters from stream and use them to initialize
      pairing.

  void pairing_clear(pairing_t pairing)
      Free the space occupied by pairing. Call whenever a pairing_t variable is
      no longer needed.


Other Pairing Functions



  void pairing_apply(element_t out, element_t in1, element_t in2, pairing_t
  pairing) {
      Apply the bilinear map described by pairing. The element out will be set
      to the map applied to in1 and in2 (in that order). in1 must be in the
      group G1, in2 must be in the group G2, and out must be in the group GT.

  int pairing_length_in_bytes_G1(pairing_t pairing)
      Returns the length in bytes needed to represent an element of G1.

  int pairing_length_in_bytes_x_only_G1(pairing_t pairing)
      Returns the length in bytes needed to represent the x-coordinate of an
      element of G1.

  int pairing_length_in_bytes_compressed_G1(pairing_t pairing)
      Returns the length in bytes needed to represent a compressed form of an
      element of G1. There is some overhead in decompressing.

  int pairing_length_in_bytes_G2(pairing_t pairing)
      Returns the length in bytes needed to represent an element of G2.

  int pairing_length_in_bytes_compressed_G2(pairing_t pairing)
      Returns the length in bytes needed to represent a compressed form of an
      element of G2. There is some overhead in decompressing.

  int pairing_length_in_bytes_x_only_G2(pairing_t pairing)
      Returns the length in bytes needed to represent the x-coordinate of an
      element of G2.

  int pairing_length_in_bytes_GT(pairing_t pairing)
      Returns the length in bytes needed to represent an element of GT.

  int pairing_length_in_bytes_Zr(pairing_t pairing)
      Returns the length in bytes needed to represent an element of Zr.


Chapter 5. Element Functions

Elements of groups, rings and fields are stored in the element_t data type.
Variables of this type must be initialized before use, and should be cleared
after they are no longer needed.
The element_ functions must be used with caution. Just as division by zero does
not make sense for integers, some operations may not make sense for particular
elements. For example, in a ring, one cannot in general invert elements.
Another caveat is that many of these functions assume their arguments come from
the same ring, group or field. No implicit type casting is performed.

Initializing Elements

When an element is initialized it is associated with an algebraic structure,
such as a particular finite field or elliptic curve group.


  void element_init_G1(element_t e, pairing_t pairing)

  void element_init_G2(element_t e, pairing_t pairing)

  void element_init_GT(element_t e, pairing_t pairing)
      Initialize e to be an element of the group G1, G2 or GT of pairing.

  void element_init_Zr(element_t e, pairing_t pairing)
      Initialize e to be an element of the ring Z_r of pairing. r is the order
      of the groups G1, G2 and GT that are involved in the pairing.

  void element_init_same_as(element_t e, element_t e2)
      Initialize e to be an element of the algebraic structure that e2 lies in.

  void element_clear(element_t e)
      Free the space occupied by e. Call this when the variable e is no longer
      needed.


Assigning Elements

These functions assign values to elements. When integers are assigned, they are
mapped to algebraic structures canonically if it makes sense (e.g. rings and
fields).


  void element_set0(element_t e)
      Set e to zero.

  void element_set1(element_t e)
      Set e to one.

  void element_set_si(element_t e, signed long int i)
      Set e to i.

  void element_set_mpz(element_t e, mpz_t z)
      Set e to z.

  void element_set(element_t e, element_t a)
      Set e to a.


Converting Elements



  void element_to_mpz(mpz_t z, element_t e)
      Converts e to a GMP integer z if such an operation makes sense

  void element_from_hash(element_t a, int len, void *data)
      Generate an element e deterministically from the len bytes stored in the
      buffer data.


Element Arithmetic

All element_t arguments to this function must have been initialized to be from
the same algebraic structure.
The addition and multiplication functions perform addition and multiplication
operations in rings and fields. For groups of points on an ellitpic curve, such
as the G1 and G2 groups associated with pairings, both addition and
multiplication represent the group operation (and similarly both 0 and 1
represent the identity element). It is recommended that programs choose and one
convention and stick with it to avoid confusion.
In contrast, the GT group is currently implemented as a subgroup of a finite
field, so only multiplicative operations should be used for GT.


  void element_add(element_t n, element_t a, element_t b)
      Set n to a + b.

  void element_sub(element_t n, element_t a, element_t b)
      Set n to a - b.

  void element_mul(element_t n, element_t a, element_t b)
      Set n to a times b.

  void element_mul_mpz(element_t n, element_t a, mpz_t z)

  void element_mul_si(element_t n, element_t a, signed long int z)
      Set n to a times z, that is a + a + ... + a where there are z a's.

  void element_square(element_t n, element_t a)
      Set n to a times a.

  void element_neg(element_t n, element_t a)
      Set n to -a.

  void element_invert(element_t n, element_t a)
      Set n to the inverse of a.


Exponentiating Elements

Exponentiation and multiexponentiation functions.


  void element_pow_mpz(element_t x, element_t a, mpz_t n)
      Set x to a raised to the power n, that is a times a times ... times a
      where there are n a's

  void element_pow_zn(element_t x, element_t a, element_t n)
      Set x to a raised to the power n, where n is an element of a ring Z_n for
      some n (typically the order of the algebraic structure x lies in).

  void element_pow2_mpz(element_t x, element_t a1, mpz_t n1, element_t a2,
  mpz_t n2)
      Sets x = a1^n1 times a2^n2, and is generally faster than performing two
      separate exponentiations.

  void element_pow2_zn(element_t x, element_t a1, element_t n1, element_t a2,
  element_t n2)
      Also sets x = a1^n1 times a2^n2, but n1, n2 must be elements of a ring
      Z_n for some integer n.

  void element_pow3_mpz(element_t x, element_t a1, mpz_t n1, element_t a2,
  mpz_t n2, element_t a3, mpz_t n3)
      Sets x = a1^n1 times ''a2^n2'' times a3^n3, and is generally faster than
      performing three separate exponentiations.

  void element_pow3_zn(element_t x, element_t a1, element_t n1, element_t a2,
  element_t n2, element_t a3, element_t n3)
      Also sets x = a1^n1 times ''a2^n2'' times a3^n3, but n1, n2, n3 must be
      elements of a ring Z_n for some integer n.


Comparing Elements

These functions compare elements from the same algebraic structure.


  int element_is1(element_t n)
      Returns 0 if n is 1, nonzero otherwise.

  int element_is0(element_t n)
      Returns 0 if n is 0, nonzero otherwise.

  int element_cmp(element_t a, element_t b)
      Returns 0 if a and b are the same, nonzero otherwise.

  int element_is_sqr(element_t a)
      Returns 0 if a is a perfect square (quadratic residue), nonzero
      otherwise.

  int element_sgn(element_t a)

  int element_sign(element_t a)
      If a is zero, returns 0. For nozero a the behaviour depends on the
      algebraic structure. For a in Z_p, returns -1 if a < p, 1 otherwise. For
      a in a polynomial ring, returns element_sgn called on the coefficient of
      the lowest degree term. Not implemented on elliptic curve groups yet.


I/O of Elements

Functions for producing human-readable outputs for elements. Converting
elements to and from bytes are discussed later.


  size_t element_out_str(FILE *stream, int base, element_t e)
      Output e on stream in base base. The base must be between 2 and 36.

  int element_fprintf(FILE *stream, const char *format, ...)

  int element_printf(const char *format, ...)
      Same as printf family except also has the 'B' conversion specifier for
      types of element_t, and 'Y', 'Z' conversion specifiers for mpz_t. For
      example if e is of type element_t then

        element_printf("%B\n", e);

      will print the value of e in a human-readable form on standard output.
      Side effect: once called, regular printf will act in the same manner.


Random Elements

Only works for finite algebraic structures. Effect on polynomial rings, fields
of characteristic zero, etc. undefined.
By default randomness is deterministic. See the chapter on randomness functions
on how to control this.


  void element_random(element_t e)
      If the e lies in a finite algebraic structure, this function assigns a
      uniformly random element to e.


Element Import/Export

Functions for serializing and deserializing elements.


  int element_length_in_bytes(element_t e)
      Returns the length in bytes the element e will take to represent

  int element_to_bytes(unsigned char *data, element_t a)
      Converts e to byte, writing the result in the buffer data. The number of
      bytes it will write can be determined from calling
      element_length_in_bytes(). Returns number of bytes written.

  int element_from_bytes(element_t a, unsigned char *data)
      Reads e from the buffer data, and returns the number of bytes read.

  int element_to_bytes_x_only(unsigned char *data, element_t e)
      Assumes e is a point on an elliptic curve. Writes the x-coordinate of e
      to the buffer data

  int element_from_bytes_x_only(element_t e, unsigned char *data)
      Assumes e is a point on an elliptic curve. Sets e to a point with x-
      coordinate represented by the buffer data. This is not unique. For each
      x-coordinate, there exist two different points, at least for the elliptic
      curves in PBC. (They are inverses of each other.)

  int element_length_in_bytes_x_only(element_t e)
      Assumes e is a point on an elliptic curve. Returns the length in bytes
      needed to hold the x-coordinate of e.

  int element_to_bytes_compressed(unsigned char *data, element_t e)
      If possible, outputs a compressed form of the element e to the buffer of
      bytes data. Currently only implemented for points on an elliptic curve.

  int element_from_bytes_compressed(element_t e, unsigned char *data)
      Sets element e to the element in compressed form in the buffer of bytes
      data. Currently only implemented for points on an elliptic curve.

  int element_length_in_bytes_compressed(element_t e)
      Returns the number of bytes needed to hold e in compressed form.
      Currently only implemented for points on an elliptic curve.


Chapter 6. Randomness Functions

By default PBC randomness is deterministic to make it easier to debug, and
because different platforms have different sources of random bits.


  void random_set_file(char *filename)
      Uses filename as a source of random bytes. For example, on Linux one
      might use /dev/random.

  void random_set_deterministic(void)
      Use a determinstic random number generator.

  void pbc_mpz_random(mpz_t z, mpz_t limit)
      Use previously chosen random number generator to select a random z that
      is less than limit.


Chapter 7. Param Functions

These functions are mainly used to generate pairing parameters. There are
several types of pairings, which, like vitamins, are labelled with capital
letters roughly in the order of discovery. Not all known pairing types are
implemented in PBC.
A good rule of thumb is to use Type A when speed is the main concern, and Type
F when group elements must be a short as possible, though in this case Type D
is faster and almost as short.

Type A

Pairings on type A curves are the fast and ought to be used where the main
concern is efficiency. Typically, r should be about 160 bits long and q about
512 bits. In this case, elements of groups G1 and G2 take 512 bits to
represent.
The file param/a.param contains parameters for a type A pairing suitable for
cryptographic use.
The a_param_t data type holds parameters for a type A pairing.


  void a_param_init(a_param_t p)
      Initialize p. This must be called before p can be used.

  void a_param_clear(a_param_t p)
      Clear p. This should be called after p is no longer needed.

  void a_param_gen(a_param_t p, int rbits, int qbits)
      Generate type A pairing parameters and store them in p, where the group
      order r is rbits long, and the order of the base field q is qbits long.
      To be secure, generic discrete log algorithms must be infeasible in
      groups of order r, and finite field discrete log algorithms must be
      infeasible in finite fields of size roughly 2qbits. Typical values: rbits
      = 160, qbits = 512.

  void a_param_out_str(FILE *stream, a_param_ptr p)
      Write the parameters in p in a text format onto stream.

  void a_param_inp_generic (a_param_ptr p, fetch_ops_t *fops, void *ctx)
      TODO

  void a_param_inp_buf(a_param_ptr p, const char *buf, size_t len)
      Read type A parameters in the above format into p from the buffer buf
      that is len bytes long.

  void a_param_inp_str(a_param_ptr p, FILE *stream)
      Read type A parameters in the above format into p from stream.


Chapter 8. Tutorial

This chapter walks through how one might implement the Boneh-Lynn-Shacham (BLS)
signature scheme using the PBC library. It is based on the file test/testsig.c.
Recall the scheme works as follows. We have three groups G1, G2, GT of prime
order r, and have some bilinear map e that takes two elements as input, one
from G1 and one from G2, and outputs an element of GT.
First we publish the system parameter g which is a randomly chosen element of
G2.
Now suppose Alice wishes to use the system. We generate her public and private
keys as follows. A private key is a random element x of Zr, and the
corresponding public key is g^x.
To sign a message, Alice hashes the message to some element h of G1, and then
outputs the signature h^x.
To verify a signature sigma, one checks that e(h,g^x) = e(sigma, g).

BLS Signatures

First we need to include pbc.h:

  #include "pbc.h"

Next we need to initialize a pairing:

      pairing_t pairing;

      pairing_init_inp_str(pairing, stdin);

Later when the program is run we will give pairing parameters to our program on
standard input. Any file in the param subdirectory will suffice.
We shall need several element_t variables to hold the system parameters, keys
and other quantities. We declare them and initialize them,

      element_t g, h;
      element_t public_key, secret_key;
      element_t sig;
      element_t temp1, temp2;

      element_init_G2(g, pairing);
      element_init_G2(public_key, pairing);
      element_init_G1(h, pairing);
      element_init_G1(sig, pairing);
      element_init_GT(temp1, pairing);
      element_init_GT(temp2, pairing);
      element_init_Zr(secret_key, pairing);

generate system parameters,

      element_random(g);

generate a private key,

      element_random(secret_key);

and the corresponding public key.

      element_pow_zn(public_key, g, secret_key);

Now suppose we are given a message. We feed it into a standard hash algorithm,
and say it outputs the string ABCDEF (I guess we're using the highly obscure
SHA-48!). We now map this string to an element h of G1,

      element_from_hash(h, 6, "ABCDEF");

then sign it:

      element_pow_zn(sig, h, secret_key);

To verify this signature, we input (signature, system parameter) to the
pairing, input (message hash, public key) to the pairing, and check the outputs
match.

      pairing_apply(temp1, sig, g, pairing);
      pairing_apply(temp2, h, public_key, pairing);

      if (!element_cmp(temp1, temp2)) {
          printf("signature verifies\n");
      } else {
          printf("signature does not verify\n");
      }


Import/Export

To be useful, at some stage the signature must be converted to bytes for
storage or transmission:

      int n = pairing_length_in_bytes_compressed_G1(pairing);
      //alternative:
      //int n = element_length_in_bytes_compressed(sig);
      unsigned char *data = malloc(n);
      element_to_bytes_compressed(data, sig);

On the other end, the signature must be decompressed:

      element_from_bytes_compressed(sig, data);

Eliding the _compressed in the above code will also work but the buffer
''data'' will be roughly twice as large.
We can save more space by using the x-coordinate of the signature only

      int n = pairing_length_in_bytes_x_only_G1(pairing);
      //alternative:
      //int n = element_length_in_bytes_x_only(sig);
      unsigned char *data = malloc(n);
      element_to_bytes_compressed(data, sig);

but then there is a complication during verification since two different points
have the same x-coordinate. One way to solve this problem is to guess one point
and try to verify. If that fails, we try the other. It can be shown that the
pairing outputs of the two points are inverses of each other, avoiding the need
to compute a pairing the second time. (Actually, there are better ways to
handle this.)

      int n = pairing_length_in_bytes_x_only_G1(pairing);
      //int n = element_length_in_bytes_x_only(sig);
      unsigned char *data = malloc(n);

      element_to_bytes_x_only(data, sig);

      element_from_bytes_x_only(sig, data)

      pairing_apply(temp1, sig, g, pairing);
      pairing_apply(temp2, h, public_key, pairing);

      if (!element_cmp(temp1, temp2)) {
          printf("signature verifies on first guess\n");
      } else {
          element_invert(temp1, temp1);
          if (!element_cmp(temp1, temp2)) {
              printf("signature verifies on second guess\n");
          } else {
              printf("signature does not verify\n");
          }
      }


Chapter 9. PBC Internals

Information on particular algebraic structures are stored in the field_t data
type, which mostly contains pointers to functions written to perform operations
such as addition and multiplication on elements of that particular group, ring
or field:

  struct field_s {
      ...
      void (*init)(element_ptr);
      void (*clear)(element_ptr);
      ...
      void (*add)(element_ptr, element_ptr, element_ptr);
      void (*sub)(element_ptr, element_ptr, element_ptr);
      void (*mul)(element_ptr, element_ptr, element_ptr);
      ...
  };
  typedef struct field_s *field_ptr;
  typedef struct field_s field_t[1];

The name algebraic_structure_t is arguably more accurate, but far too
cumbersome. If my naming choice causes discomfort, it may help if groups and
rings are simply viewed as fields where certain things don't work!
The last two lines of the above code excerpt show how GMP, and PBC, define data
types: they are actually arrays of length one so that when a variable is
declared, space is automatically allocated for it. Yet when used as a argument
to a function, a pointer is passed, thus there is no need to explicitly
allocate and deallocate memory, nor reference and dereference variables.
Each element_t contains a field named field to such a field_t variable. In
fact, the only other field is data, which stores any data needed for the
implementation of the particular algebraic structure the element resides in.

  struct element_s {
      struct field_s *field;
      void *data;
  };

When an element_t variable is initialized, its field is set, and then the
initialization specific to that field is called to complete the initialization.
Here, a line of code is worth a thousand words:

  static inline void element_init(element_t e, field_ptr f)
  {
      e->field = f;
      f->init(e);
  }

Thus when a call to one of the element_ functions, the field pointer is
followed to see which version of the function should be called, so that for
example modular addition is performed if the input element is an element of a
finite field, while polynomial addition is performed for elements of a
polynomial ring and so on.

  static inline void element_add(element_t n, element_t a, element_t b)
  {
      n->field->add(n, a, b);
  }


Justifying Design Decisions

An alternative was to require the programmer to pass the field as a parameter,
e.g. element_add(a, b, c, F_13), but I decided the added annoyance of having to
type this extra variable every time negated any benefits, such as obviating the
need for the field pointer in struct element_s. Besides, one could always write
a preprocessor to convert one type of notation to the other. (Speaking of
which, as Hovav Shacham suggested, it may be nice to eventually have a
converter that takes human-friendly infix operator expressions like a = (b + c)
* d and outputs the assembly-like element_ equivalents.)
This design may seem dangerous because if a programmer inadverdantly attempts
to add a polynomial and a point on an elliptic curve, say, the code will
compile without warnings since they have the same data type, but the results
are undefined and the library will mostly cause a crash.
However, I needed to set things up in this way because I wanted to be able to
start with a finite field and then extend it an arbitrary number of times.
(Though in practice, currently I only need to extend it twice at most.) I
wanted to be able to swap the ground field and extension fields, which is
trivial if they have the same data type.
I could have separate data types to distinguish between groups, rings and
fields. It is important to label them differently in mathematics, but here I
feel it makes more sense to lump them together under the same heading, and just
treat some kinds as handicapped.
Even if I did have a distinct data type for every kind of algebraic structure,
fields of prime order with different moduli would still fall under the same
data type, again with unpleasant results if elements are mistakenly mixed.
I have found that though my approach appears not to be type-safe, I almost
never accidently mix elements from different fields. But even if this were a
serious problem, it would not be difficult to check that the all the arguments
belong to the same field during a function call, which also addresses the issue
in the previous paragraph, and similarly check that the current algebraic
structure supports the requested operation. For example, in its simplest form:

  void element_add(element_t n, element_t a, element_t b)
  {
      assert(n->field == a-->field && a-->field == b->field);
      n->field->add(n, a, b);
  }

This library ought to have such a feature eventually to aid the less
experienced, but I have other priorities at present.
Another option is to introduce data types for each of the four pairing-related
algebraic structures, namely G1, G2, GT and Zr, as these are the only ones
needed for implementing pairing-based cryptosystems.
A minor point: The GNU_libc_manual states that data types ending in _t should
not be used because they are reserved for future additions to C or POSIX. On
the other hand, I want to stay consistent with GMP, and I hear ending data
types with _t is common practice.

Internal Randomness

Some algorithms require a quadratic nonresidue in a given field. The first time
a quadratic nonresidue is requested, one is generated at random, using the same
source of random bits as other PBC random functions.
In fieldquadratic.c, a quadratic field extension is constructed with a square
root of this randomly generated quadratic nonresidue in the base field. Thus
for a nondeterminstic source of random bits, the same field may be constructed
differently on different runs.
To construct the same field the same way every time, one must record the
quadratic nonresidue generated from one run, and call field_set_nqr() every
time this particular construction of a quadratic field extension is desired.
Another use for this function is to save time by setting the quadratic
nonresidue to some precomputed value.
Similarly, for higher degree extensions, a random irreducible polynomial may be
chosen to construct it, but this must be recorded if the same construction is
later required.
This happens behind the scenes in PBC.

Type A Internals

Type A pairings are constructed on the curve y^2 = x^3 + x over the field F_q
for some prime q. Both G1 and G2 are the group of points E(F_q), so this
pairing is symmetric. It turns out #E(F_q) = q + 1 and #E(F_q^2) = (q+1)^2.
Thus the embedding degree k is 2, and hence GT is a subgroup of F_q^2. The
order r is some prime factor of q + 1.
Write q + 1 = r * h. For efficiency, r is picked to be a Solinas prime, that
is, r has the form 2^a +- 2^b +- 1 for some integers 0 < b < a.
Also, q = -1 mod 12 so F_q^2 can be implemented as F_q[i] (where i = sqrt(-1))
and since q = -1 mod 3, cube roots in F_q are easy to compute. This latter
feature may be removed because I have not found a use for it yet (in which case
we only need q = -1 mod 4).
a_param struct fields:

exp2, exp1, sign1, sign0, r:
    r = 2^exp2 + sign1 * 2^exp1 + sign0 * 1 (Solinas prime)
q, h:
    r * h = q + 1
    q is a prime, h is a multiple of 12 (thus q = -1 mod 12)

Appendix A. Contributors

Ben Lynn wrote the original PBC library and documentation and is still
maintaining and developing it.
Hovav Shacham wrote multiexponentiation and sliding windows exponentiation
routines, Makefile improvements, and many BBS signature scheme optimizations.
Matt Steiner implemented the Boneh-Waters broadcast encryption.
Joseph Cooley wrote the GNU build system files, tested the library on Mac OS X,
and added miscellaneous improvements. Among other things, pairings can be read
from memory buffer and most compile-time warnings were removed.
Rob Figueiredo, Roger Khazan wrote changes which allow the PBC library to be
compiled on Windows (via mingw)
If you're not mentioned here but should be, please let me know! (blynn at cs
dot stanford dot edu).
