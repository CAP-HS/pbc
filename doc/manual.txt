



PBC Library Manual


Ben Lynn

Copyright Â© 2006 Ben Lynn
-------------------------------------------------------------------------------


  Preface

  1._Overview

  2._Installing_PBC

  3._PBC_Basics


        Headers_and_Libraries

        Types

        Function_Classes

        Variable_Conventions


  4._Pairing_Functions


        Initializing_Pairings

        Other_Pairing_Functions


  5._Element_Functions


        Initializing_Elements

        Assigning_Elements

        Converting_Elements

        Element_Arithmetic

        Exponentiating_Elements

        Comparing_Elements

        I/O_of_Elements

        Random_Elements

        Element_Import/Export


  6._Randomness_Functions

  A._Contributors


Preface

This manual describes how to install and use the PBC pairing-based cryptography
library version 0.3. It is modeled on the GMP manual.

Chapter 1. Overview

The PBC library is a C library designed to make it easy to implement pairing-
based cryptosystems. It provides an abstract interface to a cyclic group with a
bilinear pairing, and the programmer does not need to worry about, or even know
about elliptic curves.
It is built on top of GMP, another C library which performs arbitrary precision
arithmetic on integers, rationals and floats with strong emphasis on
portability and speed.
The PBC library homepage: http://rooster.stanford.edu/~ben/pbc/
The GMP library homepage: http://www.swox.com/gmp/

Chapter 2. Installing PBC

The PBC library needs the GMP library, which can be found at http://
www.swox.com/gmp/
This build system has been tested and works on Linux and Mac OS X with a fink
installation. You may need to specify paths via LDFLAGS and CPPFLAGS if
libraries are located in places other than the default assumed in configure.ac.
See ./configure --help for more information.

  ./configure
  make
  make install

PBC uses some GNU C extensions, notably nested functions, and also printf
extensions. The latter may be safely commented out as it is only used in
demonstration programs.

Chapter 3. PBC Basics

This chapter gives a high-level view of the library, and explains various
design choices and conventions.

Headers and Libraries

Programs using the PBC library should include the file pbc.h:

  #include <pbc.h>

and linked against the PBC library, e.g.

  gcc program.c -L. -lpbc

The file pbc.h includes gmp.h thus all GMP functions are available.
The PBC signatures library is currently bundled with PBC. Documentation will
eventually written for it, but for now look at sample signature programs in the
test directory.

Types

Since the PBC library is built on top of GMP, the GMP types are available. PBC
types are similar to GMP types. The following example is paraphrased from an
example in the GMP manual, and shows how to declare the PBC data type
element_t.

      element_t sum;

      struct foo { element_t x, y; };

      element_t vec[20];

The pairing_t data type holds bilinear pairing parameter information. There are
other data types but for many pairing-based cryptography applications they are
only needed internally.
Examples of other data types defined by PBC are field_t for rings and fields
and mpc_t for complex arbitrary precision floats.

Function Classes

PBC contains several classes of functions.

  1. Functions for dealing with bilinear pairing parameters begin with
     pairing_.
  2. Functions for operating on elements of groups, rings and fields begin with
     element_.
  3. Functions that generate pairing parameters, that is, find elliptic curves
     where efficiently computable bilinear pairings exist. The sample
     parameters bundled are adequate for many cryptosystems, but there may be a
     need to generate more.
  4. Miscellaneous functions, such as ones controlling how random bits are
     generated.


Variable Conventions

PBC follows GMP in several respects:

  1. Output arguments generally precede input arguments.
  2. The same variable can be used as input and output in one call.
  3. Before a variable may be used it must be initialized exactly once. When no
     longer needed it must be cleared. For efficiency, unnecessary
     initializating and clearing should be avoided.
  4. PBC variables ending with _t behave the same as GMP variables in function
     calls, that is effectively as call-by references. In other words, as in
     GMP, if a function that modifies an input variable, that variable remains
     modified when control return is returned to the caller.
  5. Variables automatically allocate memory via malloc() when needed. Unlike
     GMP, there is no simple way to change the memory allocator yet.
  6. The element_t type is small (but certain other types are not).

On the other hand, element_t is more complex than GMP types in that the same
data type is used for elements of different algebraic structures, such as
elliptic curve groups, polynomial rings and finite fields. Many functions
assume the inputs come from the same algebraic structure and trouble can arise
if for example one attempts to add a polynomial to a point on an elliptic
curve.
Another difference is that the programmer is expected to access some internal
fields of the pairing_t data type, though I intend to write wrappers to fix
this.

Chapter 4. Pairing Functions

An application will most likely need to instantiate a bilinear pairing before
performing any other PBC operations.
Parameters for various pairings are bundled with PBC and should be suitable for
cryptographic use. Most programs will probably want to start by initializing a
pairing by reading a set of pairing parameters.
Particular instantiations of bilinear pairings are stored in the data type
pairing_t. Functions that operate on them start with pairing_.

Initializing Pairings

The only way to initialize a pairing is to provide pairing parameters to a
pairing_t variable using one of the functions beginning with pairing_init_inp_.
For example,

  {
      pairing_t pairing;

      pairing_init_inp_str(pairing, stdin);
  }

will initialize pairing with parameters are fed to the program on standard
input.


  void pairing_init_inp_generic(pairing_t pairing, fetch_ops_t *fops, void
  *ctx)
      TODO

  void pairing_init_inp_buf(pairing_t pairing, const char *buf, size_t len)
      Read in pairing parameters from array of characters buf of length len and
      use them to initialize pairing.

  void pairing_init_inp_str(pairing_t pairing, FILE *stream)
      Read in pairing parameters from stream and use them to initialize
      pairing.

  void pairing_clear(pairing_t pairing)
      Free the space occupied by pairing. Call whenever a pairing_t variable is
      no longer needed.


Other Pairing Functions



  void pairing_apply(element_t out, element_t in1, element_t in2, pairing_t
  pairing) {
      Apply the bilinear map described by pairing. The element out will be set
      to the map applied to in1 and in2 (in that order). in1 must be in the
      group G1, in2 must be in the group G2, and out must be in the group GT.

  int pairing_length_in_bytes_G1(pairing_t pairing)
      Returns the length in bytes needed to represent an element of G1.

  int pairing_length_in_bytes_x_only_G1(pairing_t pairing)
      Returns the length in bytes needed to represent the x-coordinate of an
      element of G1.

  int pairing_length_in_bytes_G2(pairing_t pairing)
      Returns the length in bytes needed to represent an element of G2.

  int pairing_length_in_bytes_x_only_G2(pairing_t pairing)
      Returns the length in bytes needed to represent the x-coordinate of an
      element of G2.

  int pairing_length_in_bytes_GT(pairing_t pairing)
      Returns the length in bytes needed to represent an element of GT.

  int pairing_length_in_bytes_Zr(pairing_t pairing)
      Returns the length in bytes needed to represent an element of Zr.


Chapter 5. Element Functions

Elements of groups, rings and fields are stored in the element_t data type.
Variables of this type must be initialized before use, and should be cleared
after they are no longer needed.
The element_ functions must be used with caution. Just as division by zero does
not make sense for integers, some operations may not make sense for particular
elements. For example, in a ring, one cannot in general invert elements.
Another caveat is that many of these functions assume their arguments come from
the same ring, group or field. No implicit type casting is performed.

Initializing Elements

When an element is initialized it is associated with an algebraic structure,
such as a particular finite field or elliptic curve group.


  void element_init_G1(element_t e, pairing_t pairing)

  void element_init_G2(element_t e, pairing_t pairing)

  void element_init_GT(element_t e, pairing_t pairing)
      Initialize e to be an element of the group G1, G2 or GT of pairing.

  void element_init_Zr(element_t e, pairing_t pairing)
      Initialize e to be an element of the ring Zr of pairing. r is the order
      of the groups G1, G2 and GT.

  void element_init_same_as(element_t e, element_t e2)
      Initialize e to be an element of the algebraic structure that e2 lies in.

  void element_clear(element_t e)
      Free the space occupied by e. Call this when the variable e is no longer
      needed.


Assigning Elements

These functions assign values to elements. When integers are assigned, they are
mapped to algebraic structures canonically if it makes sense (e.g. rings and
fields).


  void element_set0(element_t e)
      Set e to zero.

  void element_set1(element_t e)
      Set e to one.

  void element_set_si(element_t e, signed long int i)
      Set e to i.

  void element_set_mpz(element_t e, mpz_t z)
      Set e to z.

  void element_set(element_t e, element_t a)
      Set e to a.


Converting Elements



  void element_to_mpz(mpz_t z, element_t e)
      Converts e to a GMP integer z if such an operation makes sense

  void element_from_hash(element_t a, int len, void *data)
      Generate an element e deterministically from the len bytes stored in the
      buffer data.


Element Arithmetic

All element_t arguments to this function must have been initialized to be from
the same algebraic structure.
The addition and multiplication functions perform addition and multiplication
operations in rings and fields. In groups, TODO (basically both can be used to
apply the group operation)


  void element_add(element_t n, element_t a, element_t b)
      Set n to a + b.

  void element_sub(element_t n, element_t a, element_t b)
      Set n to a - b.

  void element_mul(element_t n, element_t a, element_t b)
      Set n to a times b.

  void element_mul_mpz(element_t n, element_t a, mpz_t z)

  void element_mul_si(element_t n, element_t a, signed long int z)
      Set n to a times z, that is a + a + ... + a where there are z a's.

  void element_square(element_t n, element_t a)
      Set n to a times a.

  void element_neg(element_t n, element_t a)
      Set n to -a.

  void element_invert(element_t n, element_t a)
      Set n to the inverse of a.


Exponentiating Elements

Exponentiation and multiexponentiation functions.


  void element_pow_mpz(element_t x, element_t a, mpz_t n)
      Set x to a raised to the power n, that is a times a times ... times a
      where there are n a's

  void element_pow_zn(element_t x, element_t a, element_t n)
      Set x to a raised to the power n, where n is an element of a ring Z_n for
      some n (typically the order of the algebraic structure x lies in).

  void element_pow2_mpz(element_t x, element_t a1, mpz_t n1, element_t a2,
  mpz_t n2)
      Sets x = a1^n1 times a2^n2, and is generally faster than performing two
      separate exponentiations.

  void element_pow3_mpz(element_t x, element_t a1, mpz_t n1, element_t a2,
  mpz_t n2, element_t a3, mpz_t n3)
      Sets x = a1^n1 times a2^n2 times a3^n3, and is generally faster than
      performing three separate exponentiations.


Comparing Elements

These functions compare elements from the same algebraic structure.


  int element_is1(element_t n)
      Returns 0 if n is 1, nonzero otherwise.

  int element_is0(element_t n)
      Returns 0 if n is 0, nonzero otherwise.

  int element_cmp(element_t a, element_t b)
      Returns 0 if a and b are the same, nonzero otherwise.

  int element_is_sqr(element_t a)
      Returns 0 if a is a perfect square (quadratic residue), nonzero
      otherwise.

  int element_sgn(element_t a)

  int element_sign(element_t a)
      If a is zero, returns 0. For nozero a the behaviour depends on the
      algebraic structure. For a in Z_p, returns -1 if a < p, 1 otherwise. For
      a in a polynomial ring, returns element_sgn called on the coefficient of
      the lowest degree term. Not implemented on elliptic curve groups yet.


I/O of Elements

Functions for producing human-readable outputs for elements. Converting
elements to and from bytes are discussed later.


  size_t element_out_str(FILE *stream, int base, element_t e)
      Output e on stream in base base. The base must be between 2 and 36.

  int element_fprintf(FILE *stream, const char *format, ...)

  int element_printf(const char *format, ...)
      Same as printf family except also has the 'B' conversion specifier for
      types of element_t, and 'Y', 'Z' conversion specifiers for mpz_t. For
      example if e is of type element_t then

        element_printf("%B\n", e);

      will print the value of e in a human-readable form on standard output.
      Side effect: once called, regular printf will act in the same manner.


Random Elements

Only works for finite algebraic structures. Effect on polynomial rings, fields
of characteristic zero, etc. undefined.
By default randomness is deterministic. See the chapter on randomness functions
on how to control this.


  void element_random(element_t e)
      If the e lies in a finite algebraic structure, this function assigns a
      uniformly random element to e.


Element Import/Export

Functions for serializing and deserializing elements.


  int element_length_in_bytes(element_t e)
      Returns the length in bytes the element e will take to represent

  int element_to_bytes(unsigned char *data, element_t a)
      Converts e to byte, writing the result in the buffer data. The number of
      bytes it will write can be determined from calling
      element_length_in_bytes(). Returns number of bytes written.

  int element_from_bytes(element_t a, unsigned char *data)
      Reads e from the buffer data, and returns the number of bytes read.

  int element_to_bytes_x_only(unsigned char *data, element_t e)
      Assumes e is a point on an elliptic curve. Writes the x-coordinate of e
      to the buffer data

  int element_from_bytes_x_only(element_t e, unsigned char *data)
      Assumes e is a point on an elliptic curve. Sets e to a point with x-
      coordinate represented by the buffer data. This is not unique. For each
      x-coordinate, there exist two different points, at least for the elliptic
      curves in PBC. (They are inverses of each other.)

  int element_length_in_bytes_x_only(element_t e)
      Assumes e is a point on an elliptic curve. Returns the length in bytes
      needed to hold the x-coordinate of e.

  int element_to_bytes_compressed(unsigned char *data, element_t e)
      If possible, outputs a compressed form of the element e to the buffer of
      bytes data. Currently only implemented for points on an elliptic curve.

  int element_from_bytes_compressed(element_t e, unsigned char *data)
      Sets element e to the element in compressed form in the buffer of bytes
      data. Currently only implemented for points on an elliptic curve.

  int element_length_in_bytes_compressed(element_t e)
      Returns the number of bytes needed to hold e in compressed form.
      Currently only implemented for points on an elliptic curve.


Chapter 6. Randomness Functions

By default PBC randomness is deterministic to make it easier to debug, and
because different platforms have different sources of random bits.


  void random_set_file(char *filename)
      Uses filename as a source of random bytes. For example, on Linux one
      might use /dev/random

  void random_set_deterministic(void)
      Use a determinstic random number generator.

  void pbc_mpz_random(mpz_t z, mpz_t limit)
      Use previously chosen random number generator to select a random z that
      is less than limit.


Appendix A. Contributors

Ben Lynn wrote the original PBC library and documentation and is still
maintaining and developing it.
Hovav Shacham wrote multiexponentiation and sliding windows exponentiation
routines, Makefile improvements, and many BBS signature scheme optimizations.
Matt Steiner implemented the Boneh-Waters broadcast encryption.
Joseph Cooley wrote the GNU build system files, tested the library on Mac OS X,
and added miscellaneous improvements. Among other things, pairings can be read
from memory buffer and most compile-time warnings were removed.
Rob Figueiredo, Roger Khazan wrote changes which allow the PBC library to be
compiled on Windows (via mingw)
If you're not mentioned here but should be, please let me know! (blynn at cs
dot stanford dot edu).
