



PBC Library Manual


Ben Lynn

Copyright Â© 2006 Ben Lynn
-------------------------------------------------------------------------------


  Preface

  1._Overview

  2._Installing_PBC


        Testing_the_Library

        Test_Programs


  3._PBC_Basics


        Headers_and_Libraries

        Types

        Function_Classes

        Variable_Conventions


  4._Pairing_Functions


        Initializing_Pairings


  5._Element_Functions


        Initializing_Elements

        Assigning_Elements


  6._Pairing_Types


        Type_A

        Type_B

        Type_C

        Type_D

        Type_E

        Type_F

        Type_G

        BGN_Curves



Preface

This manual describes how to install and use the PBC pairing-based cryptography
library version 0.3. It is modeled on that of GMP. I believe it is likely that
someone using PBC would have used GMP or a similar library before so hopefully
having a similar manual will make learning PBC easier.

Chapter 1. Overview

The PBC library is a C library designed to make it easy to implement pairing-
based cryptosystems. It provides an abstract interface to a cyclic group with a
bilinear pairing, and the programmer does not need to worry about, or even know
about elliptic curves.
It is built on top of GMP, another C library which performs arbitrary precision
arithmetic on integers, rationals and floats with strong emphasis on
portability and speed.
The PBC library homepage: http://rooster.stanford.edu/~ben/pbc/
The GMP library homepage: http://www.swox.com/gmp/

Chapter 2. Installing PBC

The PBC library needs the GMP library, which can be found at http://
www.swox.com/gmp/
This build system has been tested and works on Linux and Mac OS X with a fink
installation. You may need to specify paths via LDFLAGS and CPPFLAGS if
libraries are located in places other than the default assumed in configure.ac.
See ./configure --help for more information.

  ./configure
  make
  make install

PBC uses some GNU C extensions, notably nested functions, and also printf
extensions. The latter may be safely commented out as it is only used in
demonstration programs.

Testing the Library

Several test programs and curve parameters are bundled with the library. After
compilation succeeds, try:

  test/testpairing < param/a.param
  test/benchmark < param/c159.param
  test/testibe < param/e.param

The *.param files contain pairing parameters one might typically use in a real
cryptosystem. Many of the test programs read the parameters from standard
input.

Test Programs



  listmnt
      Searches for discriminants D that lead to MNT curves with subgroups of
      prime order.

  genaparam, gencparam, geneparam, genfparam, genbgn
      Prints parameters for a curve suitable for computing pairings of a given
      type. The output can be fed to some of the other test programs.
      The program gencparam should be given a discriminant as the first
      argument.

  testhilbert
      Prints the Hilbert polynomial for a given discriminant.

  testsig, testibe
      These programs read curve parameters on standard input and perform
      computations that would be required in an implementation of the Boneh-
      Lynn-Shacham short signature scheme and the Boneh-Franklin identity-based
      encryption scheme.

  testbb, testbls, testbbs, testibs
      These test programs are more realistic, and test the implementations of
      the Boneh-Boyen, Boneh-Lynn-Shacham, Boneh-Boyen-Shacham signature
      schemes and the Cha-Cheon and Sakai-Kasahara-Schnorr identity-based
      signature schemes

  benchmark
      Reads pairing parameters on standard input and benchmarks the pairing.


Chapter 3. PBC Basics

This chapter gives a high-level view of the library, and explains various
design choices and conventions.

Headers and Libraries

Programs using the PBC library should include the file pbc.h:

  #include <pbc.h>

and linked against the PBC library, e.g.

  gcc program.c -L. -lpbc

The file pbc.h includes gmp.h thus all GMP functions are available.
The PBC signatures library is currently bundled with PBC. Documentation will
eventually written for it, but for now look at sample signature programs in the
test directory.

Types

Since the PBC library is built on top of GMP, the GMP types are available. PBC
types are similar to GMP types. The following example is paraphrased from an
example in the GMP manual, and shows how to declare the PBC data type
element_t.

      element_t sum;

      struct foo { element_t x, y; };

      element_t vec[20];

The pairing_t data type holds bilinear pairing parameter information. There are
other data types but for many pairing-based cryptography applications they are
only needed internally.
Examples of other data types defined by PBC are field_t for rings and fields
and mpc_t for complex arbitrary precision floats.

Function Classes

PBC contains several classes of functions.

  1. Functions for dealing with bilinear pairing parameters begin with with
     pairing_.
  2. Functions for operating on elements of groups, rings and fields begin with
     element_.
  3. Functions that generate pairing parameters, that is, find elliptic curves
     where efficiently computable bilinear pairings exist. The sample
     parameters bundled are adequate for many cryptosystems, but there may be a
     need to generate more.
  4. Miscellaneous functions, such as ones controlling how random bits are
     generated.


Variable Conventions

PBC follows GMP in several respects:

  1. Output arguments generally precede input arguments.
  2. The same variable can be used as input and output in one call.
  3. Before a variable may be used it must be initialized exactly once. When no
     longer needed it must be cleared. For efficiency, unnecessary
     initializating and clearing should be avoided.
  4. PBC variables ending with _t behave the same as GMP variables in function
     calls, that is effectively as call-by references. In other words, as in
     GMP, if a function that modifies an input variable, that variable remains
     modified when control return is returned to the caller.
  5. Variables automatically allocate memory via malloc() when needed. Unlike
     GMP, there is no simple way to change the memory allocator yet.
  6. The element_t type is small (but certain other types are not).

On the other hand, element_t is more complex than GMP types in that the same
data type is used for elements of different algebraic structures, such as
elliptic curve groups, polynomial rings and finite fields. Many functions
assume the inputs come from the same algebraic structure and trouble can arise
if for example one attempts to add a polynomial to a point on an elliptic
curve.
Another difference is that the programmer is expected to access some internal
fields of the pairing_t data type, though I intend to write wrappers to fix
this.

Chapter 4. Pairing Functions

An application will most likely need to instantiate a bilinear pairing before
performing any other PBC operations.
Parameters for various pairings are bundled with PBC and should be suitable for
cryptographic use. Most programs will probably want to start by initializing a
pairing by reading a set of pairing parameters.
Particular instantiations of bilinear pairings are stored in the data type
pairing_t. Functions that operate on them start with pairing_.

Initializing Pairings

The only way to initialize a pairing is to provide pairing parameters to a
pairing_t variable using one of the functions beginning with pairing_init_inp_.
For example,

  {
      pairing_t pairing;

      pairing_init_inp_str(pairing, stdin);
  }

will initialize pairing with parameters are fed to the program on standard
input.


  void pairing_init_inp_generic(pairing_t pairing, fetch_ops_t *fops, void
  *ctx)
      TODO

  void pairing_init_inp_buf(pairing_t pairing, const char *buf, size_t len)
      Read in pairing parameters from array of characters buf of length len and
      use them to initialize pairing.

  void pairing_init_inp_str(pairing_t pairing, FILE *stream)
      Read in pairing parameters from stream and use them to initialize
      pairing.

  void pairing_clear(pairing_t pairing)
      Free the space occupied by pairing. Call whenever a pairing_t variable is
      no longer needed.


Chapter 5. Element Functions

Elements of groups, rings and fields are stored in the element_t data type.
Variables of this type must be initialized before use, and should be cleared
after they are no longer needed.
The element_ functions must be used with caution. Just as division by zero does
not make sense for integers, some operations may not make sense for particular
elements. For example, in a ring, one cannot in general invert elements.
Another caveat is that many of these functions assume their arguments come from
the same ring, group or field. No implicit type casting is performed.

Initializing Elements

When an element is initialized it is associated with an algebraic structure,
such as a particular finite field or elliptic curve group.


  void element_init(element_ptr e, field_ptr f)
      Initialize e to be an element of the group, ring or field f and set it to
      be the zero element.

  void element_clear(element_ptr e)
      Free the space occupied by e. Call this when the variable e is no longer
      needed.

  void element_init_G1(element_t e, pairing_t pairing)

  void element_init_G2(element_t e, pairing_t pairing)

  void element_init_GT(element_t e, pairing_t pairing)
      Initialize e to be an element of the group G1, G2 or GT of pairing.


Assigning Elements



  void element_set0(element_ptr e)
      Set e to zero.

  void element_set1(element_ptr e)
      Set e to one.

  void element_set_si(element_ptr e, signed long int i)
      Set e to i.

  void element_set_mpz(element_ptr e, mpz_ptr z)
      Set e to z.

  void element_set(element_ptr e, element_ptr a)
      Set e to a.

Now pairing->G1, pairing->G2, pairing->GT and bilinear_map() can be used as
follows. Declare and initialize some group elements:

  element_t x, y, z;
  element_init(x, pairing->G1);
  element_init(y, pairing->G2);
  element_init(z, pairing->GT);

To pick random elements of G1, G2 and compute a pairing:

  element_random(x);
  element_random(y);
  bilinear_map(z, x, y, pairing);

Now z = e(x, y).
To raise x by some random exponent r:

  element_t r;
  element_init(r, pairing->Zr);
  element_random(r);
  element_pow_fp(x, x, r);


Chapter 6. Pairing Types

The PBC library implements the pairing using different types of curves. Which
curve to use depends on the application. To make it easy to refer to them, I
have labelled them with letters. See below for the details.
The library provides pairing parameters useful in typical pairing-based
cryptosystems. If you're not interested in what the details are, always use
Type A when a fast pairing is desired, and Type F when short group elements are
needed. Type C are not as slow as type F, but cannot be quite as short.

Type A

We use the curve y^2 = x^3 + x over the field F_q for some prime q. It turns
out #E(F_q) = q + 1 and #E(F_q^2) = (q+1)^2. Thus the embedding degree k is 2.
We set things up so that q + 1 = r * h, for a particular r. For speed, we pick
r to be a Solinas prime, that is, r has the form 2^a +- 2^b +- 1 for some
integers 0 < b < a.
We also choose q = -1 mod 12 so we can implement F_q^2 as F_q[i] (where i =
sqrt(-1)). Also, since q = -1 mod 3, cube roots in F_q are easy to compute.
This latter feature may be removed because I have not found a use for it yet
(in which case only q = -1 mod 4 is guaranteed).
Pairings on type A curves are the fast and ought to be used where the main
concern is efficiency. Typically, r should be about 160 bits long and q about
512 bits. In this case, elements of groups G1 and G2 take 512 bits to
represent.
Additionally, the pairing is symmetric, that is G1 and G2 are in fact the same
group.
a_param struct fields:

exp2, exp1, sign1, sign0, r:
    r = 2^exp2 + sign1 * 2^exp1 + sign0 * 1 (Solinas prime)
q, h:
    r * h = q + 1
    q is a prime, h is a multiple of 12 (thus q = -1 mod 12)

Type B

This type is reserved for the curve y^2 = x^3 + 1 over F_q with q = -1 mod 12.
It has yet to be implemented as I have not seen a compelling reason to use it.
There are advantages unique to this curve however. Since cube roots in F_q are
fast and guaranteed to exist, for any given value of y, it is easy to solve for
x. Also, the coefficient of x is zero in the curve equation, simplifying some
equations (e.g. point doubling).
There is also at least one drawback when compared with the similar type A
pairing. If symmetry of the pairing is insisted upon, some optimizations are
not possible. If ever implemented, perhaps I will divide this case into two
subtypes, one symmetric, and the other asymmetric but slightly faster.

Type C

This type is reserved for supersingular curves with embedding degree 6.
Pairings are fast as optimizations specific to fields of characteristic 3 may
be used. The embedding degree of 6 also means the representations of elements
of G1 are short.
On the other hand, the low characteristic also makes these curves more
susceptible to Coppersmith's attack, so slightly larger fields are needed for
security. Because of this, I have no plans to implement them in the immediate
future.

Type D

These are ordinary curves of with embedding degree 6, whose orders are prime or
a prime multiplied by a small constant. These are constructed using the method
due to MNT.
A type C curve is defined over some field F_q and has order h * r where r is a
prime and h is a small constant. Over the field F_q^6 its order is a multiple
of r^2.
Typically the order of the curve E is around 170 bits, as is F_q, the base
field, thus q^k is around the 1024-bit mark which is commonly considered good
enough.
Using type C pairings allows elements of group G1 to be quite short, typically
170-bits. Because of a certain trick, elements of group G2 need only be 3 times
longer, that is, about 510 bits rather than 6 times long. They are not quite as
short as type F pairings, but much faster.

c_param struct fields:
q   F_q is the base field
n   # of points in E(F_q)
r   large prime dividing n
h   n = h * r
a   E is given by y^2 = x^3 + ax + b
b
nk  # of points in E(F_q^k)
hk  nk = hk * r * r
I sometimes refer to a type C curve as a triplet of numbers: the discriminant,
the number of bits in the prime q, and the number of bits in the prime r. The
listmnt program prints these numbers. The bundled type C curve parameters are
the curves 9563-201-181, 62003-159-158 and 496659-224-224.

Type E

The CM (Complex Multiplication) method of constructing elliptic curves starts
with the Diophantine equation

    DV^2 = 4q - t^2
If t = 2 and q = D r^2 h^2 + 1 for some prime r (which we choose to be a
Solinas prime) and some integer h, we find that this equation is easily solved
with V = 2rh.
Thus it is easy to find a curve (over the field F_q) with order q - 1. Note r^2
divides q - 1, thus we have an embedding degree of 1.
Hence all computations necessary for the pairing can be done in F_q alone.
There is never any need to extend F_q.
As q is typically 1024 bits, group elements take a lot of space to represent.
Moreover, many optimizations do not apply to this type, resulting in a slower
pairing.
This pairing is kept as a reserve, in case some day it is discovered that
discrete log in field extensions is easier to solve than previously thought.

Type F

Using carefully crafted polynomials, k = 12 pairings can be constructed. Only
160 bits are needed to represent elements of one group, and 320 bits for the
other.
They should be used when the top priority is to minimize bandwidth (e.g. short
signatures). The pairing is slower than the other types.
Also, k = 12 allows higher security short signatures. (k = 6 curves cannot be
used to scale security from 160-bits to say 256-bits because finite field
attacks are subexponential.)

Type G

k = 10 curves may also be constructed.

BGN Curves

These are curves containing a subgroup of a specified order. Boneh, Goh and
Nissim have use for an elliptic curve with subgroup order N = pq for large
primes p, q.
To implement them, Type A curves can be used, only instead of a Solinas prime,
we generate curves with a given group order. Type B can also be used (and that
is what is suggested in their paper) but this is less desirable.
