<chapter>
<title>PBC Internals</title>
<para>
Information on particular algebraic structures are stored in the
<type>field_t</type>, which mostly contains pointers to functions
written to perform operations such as addition and multiplication
on elements of that particular group, ring or field. The name
<type>algebraic_structure_t</type> is arguably more accurate for
this data type, but it is too cumbersome. If this causes discomfort, it may
help if groups and rings are simply viewed as fields where certain things
don't work!
</para>
<para>
Each <type>element_t</type> contains a field named <parameter>field</parameter>
to such a <type>field_t</type> variable. In fact, the only other field
is <parameter>data</parameter>, which stores any data needed for the
implementation of the particular algebraic structure the element resides in.
</para>
<screen>
struct element_s {
    struct field_s *field;
    void *data;
};
</screen>
<para>
Thus when a call to one of the <type>element_</type> functions,
the <parameter>field</parameter> pointer is followed to see which
version of the function should be called, so that for example modular
addition is performed if the input element is an element of a finite field,
while polynomial addition is performed for elements of a polynomial ring
and so on.
</para>
<screen>
static inline void element_add(element_t n, element_t a, element_t b)
{
    n->field->add(n, a, b);
}
</screen>
<para>
This design may seem dangerous because if a programmer inadverdantly attempts
to add a polynomial and a point on an elliptic curve, say, the code
will compile without warnings since they have the same data type,
but the results are undefined and the library will mostly cause a crash.
</para>
<para>
However, I needed
to set things up in this way because I wanted to be able to start with
a finite field and then extend it an arbitrary number of times. (Though
in practice, currently I only need to extend it twice at most.) I wanted
to be able to swap the ground field and extension fields,
which is trivial if they have the same data type.
</para>
<para>
I could at least have separate data types to distinguish between
groups, rings and fields. It is important to clearly
label them differently in mathematics, but here it makes more sense
to lump them together under the same heading, and just treat some kinds
as handicapped.
</para>
<para>
Moreover, even if I did have a distinct data type for every kind of
algebraic structure, fields of prime order with different moduli would still
fall under the same data type, again with unpleasant results if elements
are mistakenly mixed.
</para>
<para>
I have found that even my approach appears not to be type-safe, I almost
never accidently mix elements from different fields. But even if this
were a serious problem, it would not be difficult to check that
the all the arguments belong to the same field during a function call,
which also addresses the issue in the previous paragraph, and similarly
check that the current algebraic structure supports the requested
operation.
(Of course, there should be some switch that could disable the checks
for efficiency.) This library ought to have such a feature eventually
to aid the less experienced, but I have other priorities at present.
</para>
</chapter>
