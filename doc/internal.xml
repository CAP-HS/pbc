<chapter>
<title>PBC Internals</title>
<para>
Information on particular algebraic structures are stored in the
<type>field_t</type> data type, which mostly contains pointers to functions
written to perform operations such as addition and multiplication
on elements of that particular group, ring or field:
</para>
<programlisting>
struct field_s {
    ...
    void (*init)(element_ptr);
    void (*clear)(element_ptr);
    ...
    void (*add)(element_ptr, element_ptr, element_ptr);
    void (*sub)(element_ptr, element_ptr, element_ptr);
    void (*mul)(element_ptr, element_ptr, element_ptr);
    ...
};
typedef struct field_s *field_ptr;
typedef struct field_s field_t[1];
</programlisting>
<para>
The name
<type>algebraic_structure_t</type> is arguably more accurate,
but far too cumbersome.
If my naming choice causes discomfort, it may
help if groups and rings are simply viewed as fields where certain things
don't work!
</para>
<para>
The last two lines of the above code excerpt show how GMP, and PBC, define
data types: they are actually arrays of length one so that when
a variable is declared, space is automatically allocated for it.
Yet when used as a argument to a function, a pointer is passed, thus there
is no need to explicitly allocate and deallocate memory, nor
reference and dereference variables.
</para>
<para>
Each <type>element_t</type> contains a field named <parameter>field</parameter>
to such a <type>field_t</type> variable. In fact, the only other field
is <parameter>data</parameter>, which stores any data needed for the
implementation of the particular algebraic structure the element resides in.
</para>
<programlisting>
struct element_s {
    struct field_s *field;
    void *data;
};
</programlisting>
<para>
When an <type>element_t</type> variable is initialized,
its <parameter>field</parameter> is set, and then the initialization specific
to that field is called to complete the initialization. Here, a line of
code is worth a thousand words:
</para>
<programlisting>
static inline void element_init(element_t e, field_ptr f)
{
    e->field = f;
    f->init(e);
}
</programlisting>
<para>
Thus when a call to one of the <command>element_</command> functions,
the <parameter>field</parameter> pointer is followed to see which
version of the function should be called, so that for example modular
addition is performed if the input element is an element of a finite field,
while polynomial addition is performed for elements of a polynomial ring
and so on.
</para>
<programlisting>
static inline void element_add(element_t n, element_t a, element_t b)
{
    n->field->add(n, a, b);
}
</programlisting>
<section>
<title>Justifying Design Decisions</title>
<para>
An alternative was to require the programmer to pass the field as a
parameter, e.g. <userinput>element_add(a, b, c, F_13)</userinput>, but
I decided the added annoyance of having to type this extra variable every
time negated any benefits, such as obviating the need for
the <parameter>field</parameter> pointer in
<type>struct element_s</type>. Besides, one could always write a preprocessor
to convert one type of notation to the other. (Speaking of which, as Hovav
Shacham suggested, it may be nice to eventually have a converter
that takes human-friendly infix
operator expressions like <userinput>a = (b + c) * d</userinput> and
outputs the assembly-like <command>element_</command> equivalents.)
</para>
<para>
This design may seem dangerous because if a programmer inadverdantly attempts
to add a polynomial and a point on an elliptic curve, say, the code
will compile without warnings since they have the same data type,
but the results are undefined and the library will mostly cause a crash.
</para>
<para>
However, I needed
to set things up in this way because I wanted to be able to start with
a finite field and then extend it an arbitrary number of times. (Though
in practice, currently I only need to extend it twice at most.) I wanted
to be able to swap the ground field and extension fields,
which is trivial if they have the same data type.
</para>
<para>
I could have separate data types to distinguish between
groups, rings and fields. It is important to
label them differently in mathematics, but here I feel it makes more sense
to lump them together under the same heading, and just treat some kinds
as handicapped.
</para>
<para>
Even if I did have a distinct data type for every kind of
algebraic structure, fields of prime order with different moduli would still
fall under the same data type, again with unpleasant results if elements
are mistakenly mixed.
</para>
<para>
I have found that though my approach appears not to be type-safe, I almost
never accidently mix elements from different fields. But even if this
were a serious problem, it would not be difficult to check that
the all the arguments belong to the same field during a function call,
which also addresses the issue in the previous paragraph, and similarly
check that the current algebraic structure supports the requested
operation. For example, in its simplest form:
</para>
<programlisting>
void element_add(element_t n, element_t a, element_t b)
{
    assert(n->field == a-->field &amp;&amp; a-->field == b->field);
    n->field->add(n, a, b);
}
</programlisting>
<para>
This library ought to have such a feature eventually
to aid the less experienced, but I have other priorities at present.
</para>
<para>
Another option is to introduce data types for each of the four pairing-related
algebraic structures, namely G1, G2, GT and Zr, as these are the only ones
needed for implementing pairing-based cryptosystems.
</para>
<para>
A minor point: The
<ulink url="http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html">GNU libc manual</ulink>
states that data types ending in <type>_t</type>
should not be used because they are reserved for future additions to C or POSIX.
On the other hand, I want to stay consistent with GMP, and I hear ending
data types with <type>_t</type> is common practice.
</para>
</section>
<section>
<title>Internal Randomness</title>
<para>
Some algorithms require a quadratic nonresidue in a given field. The first
time a quadratic nonresidue is requested, one is generated at random, using
the same source of random bits as other PBC random functions. [Which
reminds me, should get rid of the <parameter>nqr</parameter> field and
instead have it as part of the <parameter>data</parameter> field in
struct field_s?]
</para>
<para>
In <filename>fieldquadratic.c</filename>, a quadratic field extension
is constructed with a square root of this randomly generated
quadratic nonresidue in the base field.
Thus for a nondeterminstic source of random bits, the same field may
be constructed differently on different runs.
</para>
<para>
To construct the same field the same way every time, one must
record the quadratic nonresidue generated from one run, and call
<command>field_set_nqr()</command> every time this particular construction of a
quadratic field extension is desired. Another use for this function is
to save time by setting the quadratic nonresidue to some precomputed
value.
</para>
<para>
Similarly, for higher degree extensions, a random irreducible polynomial
may be chosen to construct it, but this must be recorded if the same
construction is later required.
</para>
<para>
This happens behind the scenes in PBC.
</para>
</section>
<section><title>Type A Internals</title>
<para>
Type A pairings are constructed on
the curve y^2 = x^3 + x over the field F_q for some prime q.
Both G1 and G2 are the group of points E(F_q), so this pairing is
symmetric.
It turns out #E(F_q) = q + 1 and #E(F_q^2) = (q+1)^2.
Thus the embedding degree k is 2, and hence GT is a subgroup of F_q^2.
The order r is some prime factor of q + 1.
</para>
<para>
Write q + 1 = r * h. For efficiency, r is picked to be a Solinas prime,
that is, r has the form 2^a +- 2^b +- 1
for some integers 0 &lt; b &lt; a.
</para>
<para>
Also, q = -1 mod 12 so F_q^2 can be implemented as F_q[i]
(where i = sqrt(-1)) and since q = -1 mod 3, cube roots in F_q
are easy to compute. This latter feature may be removed because I have
not found a use for it yet (in which case we only need q = -1 mod 4).
</para>
<para>
<function>a_param</function> struct fields:
</para>
<literallayout>
exp2, exp1, sign1, sign0, r:
    r = 2^exp2 + sign1 * 2^exp1 + sign0 * 1 (Solinas prime)
q, h:
    r * h = q + 1
    q is a prime, h is a multiple of 12 (thus q = -1 mod 12)
</literallayout>
</section>
</chapter>
