<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<book lang="en">
<bookinfo>
    <title>PBC Library Manual 0.4.18</title>
    <date>2006</date>
    <author>
        <firstname>Ben</firstname>
        <surname>Lynn</surname>
    </author>
    <authorinitials>BL</authorinitials>


</bookinfo>
<preface>
<title>Preface</title>
<simpara>The PBC library is a free portable C library allowing the rapid prototyping of
pairing-based cryptosystems. It provides an abstract interface to a cyclic
group with a bilinear pairing, insulating the programmer from mathematical
details. Knowledge of elliptic curves is optional.</simpara>

<simpara>The PBC library is built on top of the GMP library, and the PBC API is strongly
influenced by the GMP API. Accordingly, this manual tries to imitate the look
and feel of the GMP manual.</simpara>

<simpara>The PBC library homepage: <ulink url="http://crypto.stanford.edu/pbc/">http://crypto.stanford.edu/pbc/</ulink></simpara>

<simpara>The GMP library homepage: <ulink url="http://www.swox.com/gmp/">http://www.swox.com/gmp/</ulink></simpara>

</preface>
<chapter>
<title>Installing PBC</title>
<simpara>The PBC library needs <ulink url="http://www.swox.com/gmp/">the GMP library</ulink>.
Multiple ways to install PBC are provided.</simpara>

<variablelist>
<varlistentry>
<term>
GNU Build System (autotools)
</term>
<listitem>
<simpara>
  This build system has been tested and works on Linux and Mac OS X with a
  fink installation.
</simpara>
<literallayout class="monospaced">$ ./configure
$ make
$ make install</literallayout>
<simpara>By default the library is installed in <literal>/usr/local/lib</literal>.  On some systems, this
may not be in the library path. One way to fix this is to edit
<literal>/etc/ld.so.conf</literal> and run <literal>ldconfig</literal>.</simpara>

</listitem>
</varlistentry>
<varlistentry>
<term>
CMake
</term>
<listitem>
<simpara>
  A <literal>CMakeLists.txt</literal> is also provided.
  CMake is a newer tool that I prefer to use during development.
</simpara>
<literallayout class="monospaced">$ cmake .
$ make</literallayout>
</listitem>
</varlistentry>
</variablelist>
<simpara>PBC uses some GNU C extensions, notably nested functions.  For efficiency, some
of the lower-level PBC code relies on some GMP internals, which may change in
future releases. In that case, the PBC code will also have to be updated.</simpara>

</chapter>
<chapter>
<title>Quick Start</title>
<simpara>One can experiment with the PBC library without writing a single line of C.
The binary <literal>pbc/pbc</literal> should be present after PBC successfully compiles.</simpara>

<simpara>The <literal>pbc</literal> program is an interactive calculator that can be used to test the PBC
library, and also experiment with pairings in general.</simpara>

<section id="pbcintro">
<title>Playing with Pairings</title>
<simpara>We shall use the following notation. For our purposes, the pairing is a
bilinear map from two cyclic groups, G1 and G2 to a third group GT, where each
group has prime order r.</simpara>

<simpara>Run <literal>pbc/pbc</literal> and type:</simpara>

<literallayout class="monospaced">g=rnd(G1)
g</literallayout>
<simpara>The first line generates a random element g of the group G1,
while the second prints out the value of g. (The syntax was influenced
by <literal>bc</literal>, an arbitrary precision calculator.)
Next, enter:</simpara>

<literallayout class="monospaced">h=rnd(G2)
h</literallayout>
<simpara>This assigns h to a random element of the group G2. Actually, the default
pairing <literal>pbc</literal> uses is symmetric so G1 and G2 are in fact the same group, but in
general they are distinct. To compute the pairing applied to g and h, type:</simpara>

<literallayout class="monospaced">pairing(g,h)</literallayout>
<simpara>The order of both g and h is r. Let's generate two random numbers between
1 and r:</simpara>

<literallayout class="monospaced">a=rnd(Zr)
b=rnd(Zr)</literallayout>
<simpara>By bilinearity, the resulting output of both of these lines should be
identical:</simpara>

<literallayout class="monospaced">pairing(g^a,h^b)
pairing(g,h)^(a*b)</literallayout>
<simpara>This program has <link linkend="pbcref">other features</link> but the commands shown here should
be enough to quickly and interactively experiment with many pairing-based
cryptosystems using real numbers.</simpara>

</section>
</chapter>
<chapter>
<title>PBC Basics</title>
<simpara>This chapter gives a high-level view of the library, and explains
various design choices and conventions.</simpara>

<section>
<title>Headers and Libraries</title>
<simpara>Programs using the PBC library should include the file <literal>pbc.h</literal>:</simpara>

<literallayout class="monospaced">#include &lt;pbc.h&gt;</literallayout>
<simpara>and linked against the PBC library, e.g.</simpara>

<literallayout class="monospaced">$ gcc program.c -L. -lpbc</literallayout>
<simpara>The file <literal>pbc.h</literal> includes <literal>gmp.h</literal> thus all GMP functions are available.</simpara>

<simpara>To catch certain bugs, first define the PBC_DEBUG symbol before including
<literal>pbc.h</literal>:</simpara>

<literallayout class="monospaced">#define PBC_DEBUG
#include &lt;pbc.h&gt;</literallayout>
<simpara>The program will now abort when PBC detects a statement incorrectly
mixing elements from different algebraic structures. Note these checks are
performed at runtime, so this feature should be disabled for production
builds.</simpara>

</section>
<section>
<title>Types</title>
<simpara>Since the PBC library is built on top of GMP, the GMP types
are available. PBC types are similar to GMP types.
The following example is paraphrased from an example in the GMP
manual, and shows how to declare the PBC data type <literal>element_t</literal>.</simpara>

<literallayout class="monospaced">element_t sum;
struct foo { element_t x, y; };
element_t vec[20];</literallayout>
<simpara>The <literal>pairing_t</literal> data type holds bilinear pairing
parameter information. There are other data types but for many
pairing-based cryptography applications they are only needed internally.</simpara>

<simpara>Examples of other data types defined by PBC are <literal>field_t</literal>
for rings and fields and <literal>mpc_t</literal> for complex arbitrary
precision floats.</simpara>

</section>
<section>
<title>Function Classes</title>
<simpara>PBC contains several classes of functions.</simpara>

<itemizedlist>
<listitem>
<simpara>
Functions involving pairings; these begin with
<literal>pairing_</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Functions operating on elements of groups, rings and fields; these begin
with <literal>element_</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Functions generating pairings, that is, find elliptic curves
where efficiently computable bilinear pairings exist; useful if the
bundled pairings are inadequate.
</simpara>
</listitem>
<listitem>
<simpara>
Miscellaneous functions, such as ones controlling how random bits are
generated.
</simpara>
</listitem>
</itemizedlist>
</section>
<section>
<title>Conventions</title>
<simpara>PBC follows GMP in several respects:</simpara>

<itemizedlist>
<listitem>
<simpara>
Output arguments generally precede input arguments.
</simpara>
</listitem>
<listitem>
<simpara>
The same variable can be used as input and output in one call.
</simpara>
</listitem>
<listitem>
<simpara>
Before a variable may be used it must be initialized exactly once.
When no longer needed it must be cleared. For efficiency, unnecessary
initializating and clearing should be avoided.
</simpara>
</listitem>
<listitem>
<simpara>
PBC variables ending with <literal>_t</literal> behave the same as
GMP variables in function calls: effectively as call-by references.
In other words, as in GMP, if a function that modifies an input variable,
that variable remains modified when control return is returned to the caller.
</simpara>
</listitem>
<listitem>
<simpara>
Like GMP, variables automatically allocate memory when needed.
By default. <literal>malloc()</literal> and friends
are called but this can be changed.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>element_t</literal> type is small (but certain other types
are not).
</simpara>
</listitem>
<listitem>
<simpara>
PBC functions are mostly reentrant.
</simpara>
</listitem>
</itemizedlist>
<simpara>Recall GMP has the <literal>mpz_t</literal> type for integers, <literal>mpq_t</literal> for
rationals and so on.  In contrast, PBC uses the <literal>element_t</literal> data type for
elements of different algebraic structures, such as elliptic curve groups,
polynomial rings and finite fields. Many functions assume the inputs come from
the same algebraic structure and trouble can arise if for example one attempts
to add a polynomial to a point on an elliptic curve.</simpara>

<simpara>The algebraic structure that an <literal>element_t</literal> variable belongs to is specified in
an initialization call.</simpara>

</section>
</chapter>
<chapter>
<title>Tutorial</title>
<simpara>This chapter walks through how one might implement the
Boneh-Lynn-Shacham (BLS) signature scheme using the PBC library.
It is based on the file <literal>example/bls.c</literal>.</simpara>

<simpara>We have three groups <emphasis>G1</emphasis>, <emphasis>G2</emphasis>, <emphasis>GT</emphasis> of prime order <emphasis>r</emphasis>, and a bilinear map
<emphasis>e</emphasis> that takes an element from <emphasis>G1</emphasis> and an element from <emphasis>G2</emphasis>, and outputs an
element of <emphasis>GT</emphasis>. We publish these along with the system parameter <emphasis>g</emphasis>, which is
a randomly chosen element of <emphasis>G2</emphasis>.</simpara>

<simpara>Alice wishes to sign a message.  She generates her public and private keys as
follows.  Her private key is a random element <emphasis>x</emphasis> of <emphasis>Zr</emphasis>, and her corresponding
public key is <emphasis>g</emphasis><superscript><emphasis>x</emphasis></superscript>.</simpara>

<simpara>To sign a message, Alice hashes the message to some element
<emphasis>h</emphasis> of <emphasis>G1</emphasis>, and then outputs the signature <emphasis>h</emphasis><superscript><emphasis>x</emphasis></superscript>.</simpara>

<simpara>To verify a signature &sigma;, Bob checks that
<emphasis>e</emphasis>(<emphasis>h</emphasis>,<emphasis>g</emphasis><superscript><emphasis>x</emphasis></superscript>) = <emphasis>e</emphasis>(&sigma;, <emphasis>g</emphasis>).</simpara>

<simpara>We now translate the above to C code using the PBC library.</simpara>

<section>
<title>BLS Signatures</title>
<simpara>First we include <literal>pbc/pbc.h</literal>:</simpara>

<literallayout class="monospaced">#include &lt;pbc.h&gt;</literallayout>
<simpara>Next we initialize a pairing:</simpara>

<literallayout class="monospaced">pairing_t pairing;
pairing_init_inp_str(pairing, stdin);</literallayout>
<simpara>Later we give pairing parameters to our program on standard input. Any file in
the <literal>param</literal> subdirectory will suffice, for example:</simpara>

<literallayout class="monospaced">$ bls &lt; param/a.param</literallayout>
<simpara>We shall need several <literal>element_t</literal> variables to hold the system parameters, keys
and other quantities. We declare them and initialize them,</simpara>

<literallayout class="monospaced">element_t g, h;
element_t public_key, secret_key;
element_t sig;
element_t temp1, temp2;

element_init_G2(g, pairing);
element_init_G2(public_key, pairing);
element_init_G1(h, pairing);
element_init_G1(sig, pairing);
element_init_GT(temp1, pairing);
element_init_GT(temp2, pairing);
element_init_Zr(secret_key, pairing);</literallayout>
<simpara>generate system parameters,</simpara>

<literallayout class="monospaced">element_random(g);</literallayout>
<simpara>generate a private key,</simpara>

<literallayout class="monospaced">element_random(secret_key);</literallayout>
<simpara>and the corresponding public key.</simpara>

<literallayout class="monospaced">element_pow_zn(public_key, g, secret_key);</literallayout>
<simpara>When given a message to sign, we first compute its hash, using some standard
hash algorithm.  Many libraries can do this, and this operation does not
involve pairings, so PBC does not provide functions for this step. For this
example, and our message has already been hashed, possibly using another
library.</simpara>

<simpara>Say the message hash is "ABCDEF" (a 48-bit hash).  We map these bytes to an
element h of G1,</simpara>

<literallayout class="monospaced">element_from_hash(h, "ABCDEF", 6);</literallayout>
<simpara>then sign it:</simpara>

<literallayout class="monospaced">element_pow_zn(sig, h, secret_key);</literallayout>
<simpara>To verify this signature, we compare the
outputs of the pairing applied to the signature and system parameter,
and the pairing applied to the message hash and public key.
If the pairing outputs match then the signature is valid.</simpara>

<literallayout class="monospaced">pairing_apply(temp1, sig, g, pairing);
pairing_apply(temp2, h, public_key, pairing);
if (!element_cmp(temp1, temp2)) {
    printf("signature verifies\n");
} else {
    printf("signature does not verify\n");
}</literallayout>
</section>
<section>
<title>Import/Export</title>
<simpara>To be useful, at some stage the signature must be converted
to bytes for storage or transmission:</simpara>

<literallayout class="monospaced">int n = pairing_length_in_bytes_compressed_G1(pairing);
// Alternatively:
// int n = element_length_in_bytes_compressed(sig);
unsigned char *data = malloc(n);
element_to_bytes_compressed(data, sig);</literallayout>
<simpara>On the other end, the signature must be decompressed:</simpara>

<literallayout class="monospaced">element_from_bytes_compressed(sig, data);</literallayout>
<simpara>Eliding <literal>_compressed</literal> in the above code
will also work but the buffer <emphasis>data</emphasis> will be roughly twice as large.</simpara>

<simpara>We can save more space by using the <emphasis>x</emphasis>-coordinate of the signature only</simpara>

<literallayout class="monospaced">int n = pairing_length_in_bytes_x_only_G1(pairing);
//alternative:
//int n = element_length_in_bytes_x_only(sig);
unsigned char *data = malloc(n);
element_to_bytes_compressed(data, sig);</literallayout>
<simpara>but then there is a complication during verification since two different
points have the same <emphasis>x</emphasis>-coordinate. One way to solve this problem is to
guess one point and try to verify. If that fails, we try the other.
It can be shown that the pairing outputs of the two points are inverses
of each other, avoiding the need to compute a pairing the second time.
(In fact, there are even better ways to handle this.)</simpara>

<literallayout class="monospaced">int n = pairing_length_in_bytes_x_only_G1(pairing);
//int n = element_length_in_bytes_x_only(sig);
unsigned char *data = malloc(n);

element_to_bytes_x_only(data, sig);

element_from_bytes_x_only(sig, data)

pairing_apply(temp1, sig, g, pairing);
pairing_apply(temp2, h, public_key, pairing);

if (!element_cmp(temp1, temp2)) {
    printf("signature verifies on first guess\n");
} else {
    element_invert(temp1, temp1);
    if (!element_cmp(temp1, temp2)) {
        printf("signature verifies on second guess\n");
    } else {
        printf("signature does not verify\n");
    }
}</literallayout>
</section>
</chapter>
<chapter>
<title>Pairing Functions</title>
<simpara>An application will most likely need to instantiate a bilinear pairing
before performing any other operations.
The easiest way to do this is to initialize a pairing with
previously-generated pairing parameters.</simpara>

<simpara>Parameters for various pairings are included with
the PBC library distribution in the
<literal>param</literal> subdirectory and should
be suitable for cryptographic use. Some programs in
the <literal>gen</literal> subdirectory may be used to
generate parameters (see the chapter on bundled programs).
Also, on the PBC website an archive containing many pairing
parameters is available for download.</simpara>

<simpara>Particular instantiations of bilinear pairings are stored in the data
type <literal>pairing_t</literal>. Functions that operate on them
start with <literal>pairing_</literal>.</simpara>

<simpara>Pairings involve three groups of prime order. The PBC library labels them
G1, G2, and GT, and labels the order r. The pairing is
a bilinear map that takes two elements as input,
one from G1 and one from G2, and outputs an element of GT.</simpara>

<simpara>The elements of G2 are at least as long as G1; G1 is guaranteed to be the
shorter of the two. Sometimes G1 and G2 are the same group (i.e. the pairing
is symmetric) so their elements can be mixed freely. In this case the
<literal>pairing_is_symmetric</literal> function returns 1.</simpara>

<simpara>A later chapter discusses <link linkend="paramchap">the different pairing types</link>.</simpara>

<section>
<title>Initializing Pairings</title>
<simpara>The only way to initialize a pairing
is to provide pairing parameters to a <literal>pairing_t</literal>
variable using one of the functions
beginning with <literal>pairing_init_inp_</literal>. For example,</simpara>

<literallayout class="monospaced">pairing_t pairing;
pairing_init_inp_str(pairing, stdin);</literallayout>
<simpara>will initialize <literal>pairing</literal> with
parameters are fed to the program on standard
input.</simpara>

<simpara>The format of the pairing parameters is a text format that
is output by the param functions.</simpara>

<simpara>void  <emphasis role="strong">pairing_init_inp_buf</emphasis>(<emphasis>pairing_t pairing</emphasis>, <emphasis>const char *buf</emphasis>, <emphasis>size_t len</emphasis>)</simpara>

<blockquote>
<simpara>Read in pairing parameters from array of characters <emphasis>buf</emphasis> of length <emphasis>len</emphasis>
and use them to initialize <emphasis>pairing</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pairing_init_inp_str</emphasis>(<emphasis>pairing_t pairing</emphasis>, <emphasis>FILE *stream</emphasis>)</simpara>

<blockquote>
<simpara>Read in pairing parameters from <emphasis>stream</emphasis>
and use them to initialize <emphasis>pairing</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pairing_clear</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Free the space occupied by <emphasis>pairing</emphasis>. Call
whenever a <literal>pairing_t</literal> variable is no longer needed.
Only call this after all elements associated with <emphasis>pairing</emphasis>
have been cleared, as they need information stored in the <emphasis>pairing</emphasis>
structure.</simpara>

</blockquote>
</section>
<section>
<title>Applying Pairings</title>
<simpara>The function <literal>pairing_apply</literal> can be called to apply a bilinear map.  The order
of the inputs is important. The first, which holds the output, must be from the
group GT. The second must be from G1, the third from G2, and the fourth must be
the <literal>pairing_t</literal> variable that relates them.  (One cannot mix and match G1, G2,
and GT groups from different pairings.)</simpara>

<simpara>In some applications, the programmer may know that many pairings with the same
G1 input will be computed. In this case, preprocessing should be used to avoid
repeating many calculations saving time in the long run.  A variable of type
<literal>pairing_pp_t</literal> should be declared, initialized with the fixed G1 element, and
then used to compute pairings:</simpara>

<literallayout class="monospaced">pairing_pp_t pp;
pairing_pp_init(pp, x, pairing); // x is some element of G1
pairing_pp_apply(r1, y1, pp); // r1 = e(x, y1)
pairing_pp_apply(r2, y2, pp); // r2 = e(x, y2)
pairing_pp_clear(pp); // don't need pp anymore</literallayout>
<simpara>void  <emphasis role="strong">pairing_pp_init</emphasis>(<emphasis>pairing_pp_t p</emphasis>, <emphasis>element_t in1</emphasis>, <emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Get ready to perform a pairing whose first input is <emphasis>in1</emphasis>,
and store the results of time-saving precomputation in <emphasis>p</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pairing_pp_clear</emphasis>(<emphasis>pairing_pp_t p</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pairing_pp_apply</emphasis>(<emphasis>element_t out</emphasis>, <emphasis>element_t in2</emphasis>, <emphasis>pairing_pp_t p</emphasis>)</simpara>

<blockquote>
<simpara>Compute a pairing using <emphasis>in2</emphasis> and the preprocessed information stored in <emphasis>p</emphasis>
and store the output in <emphasis>out</emphasis>. The inputs to the pairing are the element
previously used to initialize <emphasis>p</emphasis> and the element <emphasis>in2</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pairing_apply</emphasis>(<emphasis>element_t out</emphasis>, <emphasis>element_t in1</emphasis>, <emphasis>element_t in2</emphasis>, <emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Apply the bilinear map described by <emphasis>pairing</emphasis>. The element <emphasis>out</emphasis>
will be set to the map applied to <emphasis>in1</emphasis> and <emphasis>in2</emphasis>, that is
<emphasis>out</emphasis> = <emphasis>e</emphasis>(<emphasis>in1</emphasis>, <emphasis>in2</emphasis>).
<emphasis>in1</emphasis> must be in the group G1,
<emphasis>in2</emphasis> must be in the group G2, and
<emphasis>out</emphasis> must be in the group GT.</simpara>

</blockquote>
</section>
<section>
<title>Other Pairing Functions</title>
<simpara>int  <emphasis role="strong">pairing_is_symmetric</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns true if G1 and G2 are the same group.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_G1</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent an element of G1.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_x_only_G1</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent the x-coordinate of
an element of G1.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_compressed_G1</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent a compressed form of
an element of G1. There is some overhead in decompressing.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_G2</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent an element of G2.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_compressed_G2</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent a compressed form of
an element of G2. There is some overhead in decompressing.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_x_only_G2</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent the x-coordinate of
an element of G2.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_GT</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent an element of GT.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">pairing_length_in_bytes_Zr</emphasis>(<emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes needed to represent an element of Zr.</simpara>

</blockquote>
</section>
<section>
<title>Element Functions</title>
<simpara>Elements of groups, rings and fields are stored in the <literal>element_t</literal> data type.
Variables of this type must be initialized before use, and should be cleared
after they are no longer needed.</simpara>

<simpara>The <literal>element_</literal> functions must be used with caution.  Just as division by zero
does not make sense for integers, some operations may not make sense for
particular elements. For example, in a ring, one cannot in general invert
elements.</simpara>

<simpara>Another caveat is that many of these functions assume their arguments come from
the same ring, group or field. No implicit type casting is performed.</simpara>

<simpara>Because of the way PBC is designed, checking that elements from different
algberaic structures have not been mistakenly mixed is not easy to do at
compile-time. Instead, runtime checks are performed if PBC_DEBUG is defined
before the PBC header file is included:</simpara>

<literallayout class="monospaced">#define PBC_DEBUG
#include &lt;pbc.h&gt;</literallayout>
<simpara>This feature impairs performance so should be disabled in the final build.</simpara>

</section>
<section>
<title>Initializing Elements</title>
<simpara>When an element is initialized it is associated with an algebraic structure,
such as a particular finite field or elliptic curve group.</simpara>

<simpara>void  <emphasis role="strong">element_init_G1</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>pairing_t pairing</emphasis>)</simpara>

<simpara>void  <emphasis role="strong">element_init_G2</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>pairing_t pairing</emphasis>)</simpara>

<simpara>void  <emphasis role="strong">element_init_GT</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>e</emphasis> to be an element of the group G1, G2 or GT of <emphasis>pairing</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_init_Zr</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>pairing_t pairing</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>e</emphasis> to be an element of the ring Z_r of <emphasis>pairing</emphasis>.
r is the order of the groups G1, G2 and GT that are involved in the pairing.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_init_same_as</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>element_t e2</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>e</emphasis> to be an element of the algebraic structure that <emphasis>e2</emphasis>
lies in.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_clear</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Free the space occupied by <emphasis>e</emphasis>. Call this when
the variable <emphasis>e</emphasis> is no longer needed.</simpara>

</blockquote>
</section>
<section>
<title>Assigning Elements</title>
<simpara>These functions assign values to elements. When integers are assigned,
they are mapped to algebraic structures canonically if it makes sense
(e.g. rings and fields).</simpara>

<simpara>void  <emphasis role="strong">element_set0</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>e</emphasis> to zero.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_set1</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>e</emphasis> to one.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_set_si</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>signed long int i</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>e</emphasis> to <emphasis>i</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_set_mpz</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>mpz_t z</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>e</emphasis> to <emphasis>z</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_set</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>e</emphasis> to <emphasis>a</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Converting Elements</title>
<simpara>void  <emphasis role="strong">element_to_mpz</emphasis>(<emphasis>mpz_t z</emphasis>, <emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Converts <emphasis>e</emphasis> to a GMP integer <emphasis>z</emphasis>
if such an operation makes sense</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_from_hash</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>void *data</emphasis>, <emphasis>int len</emphasis>)</simpara>

<blockquote>
<simpara>Generate an element <emphasis>e</emphasis> deterministically from
the <emphasis>len</emphasis> bytes stored in the buffer <emphasis>data</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Element Arithmetic</title>
<simpara>Unless otherwise stated, all <literal>element_t</literal> arguments to these functions must have
been initialized to be from the same algebraic structure.  When one of these
functions expects its arguments to be from particular algebraic structures,
this is reflected in the name of the function.</simpara>

<simpara>The addition and multiplication functions perform addition and multiplication
operations in rings and fields. For groups of points on an ellitpic curve, such
as the G1 and G2 groups associated with pairings, both addition and
multiplication represent the group operation (and similarly both 0 and 1
represent the identity element).  It is recommended that programs choose and
one convention and stick with it to avoid confusion.</simpara>

<simpara>In contrast, the GT group is currently
implemented as a subgroup of a finite field, so only multiplicative operations
should be used for GT.</simpara>

<simpara>void  <emphasis role="strong">element_add</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>element_t b</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> to <emphasis>a</emphasis> + <emphasis>b</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_sub</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>element_t b</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> to <emphasis>a</emphasis> - <emphasis>b</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_mul</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>element_t b</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = <emphasis>a</emphasis> <emphasis>b</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_mul_mpz</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>mpz_t z</emphasis>)</simpara>

<simpara>void  <emphasis role="strong">element_mul_si</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>signed long int z</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = <emphasis>a</emphasis> <emphasis>z</emphasis>, that is <emphasis>a</emphasis> + <emphasis>a</emphasis> + &#8230; + <emphasis>a</emphasis> where there are <emphasis>z</emphasis> <emphasis>a</emphasis>'s.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_mul_zn</emphasis>(<emphasis>element_t c</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>element_t z</emphasis>)</simpara>

<blockquote>
<simpara><emphasis>z</emphasis> must be an element of a integer mod ring (i.e. <emphasis role="strong">Z</emphasis><subscript>n</subscript> for some n).
Set <emphasis>c</emphasis> = <emphasis>a</emphasis> <emphasis>z</emphasis>, that is <emphasis>a</emphasis> + <emphasis>a</emphasis> + &#8230; + <emphasis>a</emphasis>
where there are <emphasis>z</emphasis> <emphasis>a</emphasis>'s.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_div</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>element_t b</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = <emphasis>a</emphasis> / <emphasis>b</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_double</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = <emphasis>a</emphasis> + <emphasis>a</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_halve</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = <emphasis>a/2</emphasis></simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_square</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = <emphasis>a</emphasis><superscript>2</superscript></simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_neg</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> = -<emphasis>a</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_invert</emphasis>(<emphasis>element_t n</emphasis>, <emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>n</emphasis> to the inverse of <emphasis>a</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Exponentiating Elements</title>
<simpara>Exponentiation and multiexponentiation functions.  If it is known in advance
that a particular element will be exponentiated several times in the future,
time can be saved in the long run by first calling the preprocessing function:</simpara>

<literallayout class="monospaced">element_pp_t g_pp;
element_pp_init(g_pp, g);
element_pp_pow(h, pow1, g_pp); // h = g^pow1
element_pp_pow(h, pow2, g_pp); // h = g^pow2
element_pp_pow(h, pow3, g_pp); // h = g^pow3
element_pp_clear(g_pp);</literallayout>
<simpara>void  <emphasis role="strong">element_pow_mpz</emphasis>(<emphasis>element_t x</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>mpz_t n</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>x</emphasis> = <emphasis>a</emphasis><superscript><emphasis>n</emphasis></superscript>, that is
<emphasis>a</emphasis> times <emphasis>a</emphasis> times &#8230; times <emphasis>a</emphasis> where there are <emphasis>n</emphasis> <emphasis>a</emphasis>'s.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pow_zn</emphasis>(<emphasis>element_t x</emphasis>, <emphasis>element_t a</emphasis>, <emphasis>element_t n</emphasis>)</simpara>

<blockquote>
<simpara>Set <emphasis>x</emphasis> = <emphasis>a</emphasis><superscript><emphasis>n</emphasis></superscript>, where <emphasis>n</emphasis> is an element of a ring <emphasis role="strong">Z</emphasis><subscript>N</subscript>
for some <emphasis>N</emphasis> (typically the order of the algebraic structure <emphasis>x</emphasis> lies in).</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pow2_mpz</emphasis>(<emphasis>element_t x</emphasis>, <emphasis>element_t a1</emphasis>, <emphasis>mpz_t n1</emphasis>, <emphasis>element_t a2</emphasis>, <emphasis>mpz_t n2</emphasis>)</simpara>

<blockquote>
<simpara>Sets <emphasis>x</emphasis> = <emphasis>a1</emphasis><superscript><emphasis>n1</emphasis></superscript> <emphasis>a2</emphasis><superscript><emphasis>n2</emphasis></superscript>, and is generally faster than
performing two separate exponentiations.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pow2_zn</emphasis>(<emphasis>element_t x</emphasis>, <emphasis>element_t a1</emphasis>, <emphasis>element_t n1</emphasis>, <emphasis>element_t a2</emphasis>, <emphasis>element_t n2</emphasis>)</simpara>

<blockquote>
<simpara>Also sets <emphasis>x</emphasis> = <emphasis>a1</emphasis><superscript><emphasis>n1</emphasis></superscript> <emphasis>a2</emphasis><superscript><emphasis>n2</emphasis></superscript>,
but <emphasis>n1</emphasis>, <emphasis>n2</emphasis> must be elements of a ring <emphasis role="strong">Z</emphasis><subscript>n</subscript> for some integer n.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pow3_mpz</emphasis>(<emphasis>element_t x</emphasis>, <emphasis>element_t a1</emphasis>, <emphasis>mpz_t n1</emphasis>, <emphasis>element_t a2</emphasis>, <emphasis>mpz_t n2</emphasis>, <emphasis>element_t a3</emphasis>, <emphasis>mpz_t n3</emphasis>)</simpara>

<blockquote>
<simpara>Sets <emphasis>x</emphasis> = <emphasis>a1</emphasis><superscript><emphasis>n1</emphasis></superscript> <emphasis>a2</emphasis><superscript><emphasis>n2</emphasis></superscript> <emphasis>a3</emphasis><superscript><emphasis>n3</emphasis></superscript>,
generally faster than performing three separate exponentiations.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pow3_zn</emphasis>(<emphasis>element_t x</emphasis>, <emphasis>element_t a1</emphasis>, <emphasis>element_t n1</emphasis>, <emphasis>element_t a2</emphasis>, <emphasis>element_t n2</emphasis>, <emphasis>element_t a3</emphasis>, <emphasis>element_t n3</emphasis>)</simpara>

<blockquote>
<simpara>Also sets <emphasis>x</emphasis> = <emphasis>a1</emphasis><superscript><emphasis>n1</emphasis></superscript> <emphasis>a2</emphasis><superscript><emphasis>n2</emphasis></superscript> <emphasis>a3</emphasis><superscript><emphasis>n3</emphasis></superscript>,
but <emphasis>n1</emphasis>, <emphasis>n2</emphasis>, <emphasis>n3</emphasis> must be elements of a ring <emphasis role="strong">Z</emphasis><subscript>n</subscript> for some integer n.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pp_init</emphasis>(<emphasis>element_pp_t p</emphasis>, <emphasis>element_t in</emphasis>)</simpara>

<blockquote>
<simpara>Prepare to exponentiate an element <emphasis>in</emphasis>, and store preprocessing information
in <emphasis>p</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pp_clear</emphasis>(<emphasis>element_pp_t p</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. Should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">element_pp_pow</emphasis>(<emphasis>element_t out</emphasis>, <emphasis>mpz_t power</emphasis>, <emphasis>element_pp_t p</emphasis>)</simpara>

<blockquote>
<simpara>Raise <emphasis>in</emphasis> to <emphasis>power</emphasis> and store the result in <emphasis>out</emphasis>, where <emphasis>in</emphasis>
is a previously preprocessed element, that is, the second argument
passed to a previous <emphasis role="strong">element_pp_init</emphasis> call.</simpara>

</blockquote>
</section>
<section>
<title>Comparing Elements</title>
<simpara>These functions compare elements from the same algebraic structure.</simpara>

<simpara>int  <emphasis role="strong">element_is1</emphasis>(<emphasis>element_t n</emphasis>)</simpara>

<blockquote>
<simpara>Returns true if <emphasis>n</emphasis> is 1.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_is0</emphasis>(<emphasis>element_t n</emphasis>)</simpara>

<blockquote>
<simpara>Returns true if <emphasis>n</emphasis> is 0.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_cmp</emphasis>(<emphasis>element_t a</emphasis>, <emphasis>element_t b</emphasis>)</simpara>

<blockquote>
<simpara>Returns 0 if <emphasis>a</emphasis> and <emphasis>b</emphasis> are the same, nonzero otherwise.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_is_sqr</emphasis>(<emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>Returns nonzero if <emphasis>a</emphasis> is a perfect square (quadratic residue),
zero otherwise.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_sgn</emphasis>(<emphasis>element_t a</emphasis>)</simpara>

<simpara>int  <emphasis role="strong">element_sign</emphasis>(<emphasis>element_t a</emphasis>)</simpara>

<blockquote>
<simpara>If <emphasis>a</emphasis> is zero, returns 0. For nozero <emphasis>a</emphasis> the behaviour depends on
the algebraic structure, but has the property that
element_sgn(<emphasis>a</emphasis>) = -element_sgn(-<emphasis>a</emphasis>)
and
element_sgn(<emphasis>a</emphasis>) = 0 implies <emphasis>a</emphasis> = 0 with overwhelming probability.</simpara>

</blockquote>
</section>
<section>
<title>I/O of Elements</title>
<simpara>Functions for producing human-readable outputs for elements.
Converting elements to and from bytes are discussed later.</simpara>

<simpara>size_t  <emphasis role="strong">element_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>int base</emphasis>, <emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Output <emphasis>e</emphasis> on <emphasis>stream</emphasis> in base <emphasis>base</emphasis>. The base must be between
2 and 36.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_printf</emphasis>(<emphasis>const char *format</emphasis>, <emphasis>&#8230;</emphasis>)</simpara>

<simpara>int  <emphasis role="strong">element_fprintf</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>const char *format</emphasis>, <emphasis>&#8230;</emphasis>)</simpara>

<simpara>int element_snprintf  **(<emphasis>char *buf</emphasis>, <emphasis>size_t size</emphasis>, <emphasis>const char *fmt</emphasis>, <emphasis>&#8230;</emphasis>)</simpara>

<blockquote>
<simpara>Same as printf family
except also has the <emphasis>B</emphasis> conversion specifier for types
of <emphasis role="strong">element_t</emphasis>, and <emphasis>Y</emphasis>, <emphasis>Z</emphasis> conversion specifiers for
<literal>mpz_t</literal>. For example if <emphasis>e</emphasis> is of type
<literal>element_t</literal> then</simpara>

<literallayout class="monospaced">element_printf("%B\n", e);</literallayout>
<simpara>will print the value of <emphasis>e</emphasis> in a human-readable form on standard output.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_snprint</emphasis>(<emphasis>char *s</emphasis>, <emphasis>size_t n</emphasis>, <emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Convert an element to a human-friendly string.
Behaves as <emphasis role="strong">snprintf</emphasis> but only on one element at a time.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_set_str</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>char *s</emphasis>, <emphasis>int base</emphasis>)</simpara>

<blockquote>
<simpara>Set the element <emphasis>e</emphasis> from <emphasis>s</emphasis>, a null-terminated C string in base <emphasis>base</emphasis>.
Whitespace is ignored. Points have the form "[<emphasis>x,y</emphasis>]" or "<emphasis>O</emphasis>",
while polynomials have the form "[<emphasis>a0,&#8230;,an</emphasis>]".
Returns number of characters read (unlike GMP's mpz_set_str).
A return code of zero means PBC could not find a well-formed string
describing an element.</simpara>

</blockquote>
</section>
<section>
<title>Random Elements</title>
<simpara>Only works for finite algebraic structures. Effect on polynomial rings, fields
of characteristic zero, etc. undefined.</simpara>

<simpara>See the chapter on randomness functions on where PBC gets random bits from and
how to select a different source of random bits.</simpara>

<simpara>void  <emphasis role="strong">element_random</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>If the <emphasis>e</emphasis> lies in a finite algebraic structure,
assigns a uniformly random element to <emphasis>e</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Element Import/Export</title>
<simpara>Functions for serializing and deserializing elements.</simpara>

<simpara>int  <emphasis role="strong">element_length_in_bytes</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Returns the length in bytes the element <emphasis>e</emphasis> will take to represent</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_to_bytes</emphasis>(<emphasis>unsigned char *data</emphasis>, <emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Converts <emphasis>e</emphasis> to byte, writing the result in the buffer <emphasis>data</emphasis>.
The number of bytes it will write can be determined from calling
<emphasis role="strong">element_length_in_bytes()</emphasis>. Returns number of bytes written.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_from_bytes</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>unsigned char *data</emphasis>)</simpara>

<blockquote>
<simpara>Reads <emphasis>e</emphasis> from the buffer <emphasis>data</emphasis>, and returns the number of bytes read.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_to_bytes_x_only</emphasis>(<emphasis>unsigned char *data</emphasis>, <emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Assumes <emphasis>e</emphasis> is a point on an elliptic curve.
Writes the x-coordinate of <emphasis>e</emphasis> to the buffer <emphasis>data</emphasis></simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_from_bytes_x_only</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>unsigned char *data</emphasis>)</simpara>

<blockquote>
<simpara>Assumes <emphasis>e</emphasis> is a point on an elliptic curve.
Sets <emphasis>e</emphasis> to a point with
x-coordinate represented by the buffer <emphasis>data</emphasis>. This is not unique.
For each <emphasis>x</emphasis>-coordinate, there exist two different points, at least
for the elliptic curves in PBC. (They are inverses of each other.)</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_length_in_bytes_x_only</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Assumes <emphasis>e</emphasis> is a point on an elliptic curve.
Returns the length in bytes needed to hold the x-coordinate of <emphasis>e</emphasis>.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_to_bytes_compressed</emphasis>(<emphasis>unsigned char *data</emphasis>, <emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>If possible, outputs a compressed form of the element <emphasis>e</emphasis> to
the buffer of bytes <emphasis>data</emphasis>.
Currently only implemented for points on an elliptic curve.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_from_bytes_compressed</emphasis>(<emphasis>element_t e</emphasis>, <emphasis>unsigned char *data</emphasis>)</simpara>

<blockquote>
<simpara>Sets element <emphasis>e</emphasis> to the element in compressed form in the buffer of bytes
<emphasis>data</emphasis>.
Currently only implemented for points on an elliptic curve.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">element_length_in_bytes_compressed</emphasis>(<emphasis>element_t e</emphasis>)</simpara>

<blockquote>
<simpara>Returns the number of bytes needed to hold <emphasis>e</emphasis> in compressed form.
Currently only implemented for points on an elliptic curve.</simpara>

</blockquote>
</section>
</chapter>
<chapter id="paramchap">
<title>Param Functions</title>
<simpara>These functions are mainly used to generate pairing parameters.
There are several types of pairings, which, like vitamins, are
labelled with capital letters roughly in the order of discovery.</simpara>

<simpara>Not all known pairing types are implemented in PBC. We only consider
pairings whose group order is close to the field size.
Type C takes place in a field of low
characteristic, which makes it susceptible to the Coppersmith attack,
reducing its utility.
I hope to implement Type B soon.</simpara>

<simpara>Type A is best when speed is the main concern.
Type D is a good choice when elements should be short but is slower
(can be roughly two to five times slower).
Type F has even shorter elements but is slower still (can be at least
ten times slower than type A).
The speed differences are hardware-dependent,
and also change when preprocessing is used.</simpara>

<simpara>PBC uses G1 to denote the group with the shorter representation (G1 is
the group of points over the ground field) when G1 and G2 differ.</simpara>

<section>
<title>Type A</title>
<simpara>Pairings on type A curves are the fast and ought to be used where the
main concern is efficiency. Typically, r should be about 160 bits long
and q about 512 bits. In this case, elements of groups G1 and G2 take
512 bits to represent.</simpara>

<simpara>The file <literal>param/a.param</literal> contains parameters for a
type A pairing suitable for cryptographic use.</simpara>

<simpara>The <literal>a_param_t</literal> data type holds parameters for a type A pairing.</simpara>

<simpara>void  <emphasis role="strong">a_param_init</emphasis>(<emphasis>a_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>p</emphasis>. This must be called before <emphasis>p</emphasis> can be used.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">a_param_clear</emphasis>(<emphasis>a_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">a_param_gen</emphasis>(<emphasis>a_param_t p</emphasis>, <emphasis>int rbits</emphasis>, <emphasis>int qbits</emphasis>)</simpara>

<blockquote>
<simpara>Generate type A pairing parameters and store them in <emphasis>p</emphasis>, where the group order
r is <emphasis>rbits</emphasis> long, and the order of the base field q is <emphasis>qbits</emphasis> long.  To be
secure, generic discrete log algorithms must be infeasible in groups of order
r, and finite field discrete log algorithms must be infeasible in finite fields
of order q<superscript>2</superscript>.</simpara>

<simpara>Typical values: <emphasis>rbits</emphasis> = 160, <emphasis>qbits</emphasis> = 512.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">a_param_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>a_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Write the parameters in <emphasis>p</emphasis> in a text format onto <emphasis>stream</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Type A1</title>
<simpara>Some pairing-based cryptosystems require the group order to be a particular
composite number. Fortunately, it is easy to find type A pairings with
any given order. Such pairings are designated type A1 in the library.</simpara>

<simpara>The file <literal>param/a1.param</literal> contains sample parameters for a
type A1 pairing, but it is most likely not useful as it does not provide
the factorization of <literal>n</literal>, the order of the group.</simpara>

<simpara>The <literal>a1_param_t</literal> data type holds parameters for a type A1 pairing.</simpara>

<simpara>void  <emphasis role="strong">a1_param_init</emphasis>(<emphasis>a1_param_t param</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>p</emphasis>. This must be called before <emphasis>p</emphasis> can be used.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">a1_param_clear</emphasis>(<emphasis>a1_param_t param</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">a1_param_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>a1_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Write the parameters in <emphasis>p</emphasis> in a text format onto <emphasis>stream</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">a1_param_gen</emphasis>(<emphasis>a1_param_t param</emphasis>, <emphasis>mpz_t n</emphasis>)</simpara>

<blockquote>
<simpara>Generate type A1 pairing parameters and store them in <emphasis>p</emphasis>.  The group order
will be <emphasis>n</emphasis>. The order of the base field is a few bits longer.  To be secure,
generic discrete log algorithms must be infeasible in groups of order <emphasis>n</emphasis>, and
finite field discrete log algorithms must be infeasible in finite fields of
order roughly <emphasis>n</emphasis><superscript>2</superscript>.  Additionally, <emphasis>n</emphasis> should be hard to factorize.</simpara>

<simpara>For example: <emphasis>n</emphasis> a product of two primes, each at least 512 bits.</simpara>

</blockquote>
</section>
<section>
<title>Type D</title>
<simpara>Using type D pairings allows elements of group G1 to be quite short, typically
170-bits. Because of a certain trick, elements of group G2 need only be 3 times
longer, that is, about 510 bits rather than 6 times long. They are not quite
as short as type F pairings, but much faster.</simpara>

<simpara>I sometimes refer to a type D curve as a triplet of numbers: the discriminant,
the number of bits in the prime q, and the number of bits in the prime r. The
<literal>gen/listmnt</literal> program prints these numbers.</simpara>

<simpara>Among the bundled type D curve parameters are the curves 9563-201-181,
62003-159-158 and 496659-224-224 which have shortened names <literal>param/d201.param</literal>,
<literal>param/d159.param</literal> and <literal>param/d225.param</literal> respectively.</simpara>

<simpara>The <literal>d_param_t</literal> data type holds parameters for a type D pairing.</simpara>

<simpara>See <literal>gen/listmnt.c</literal> and <literal>gen/gendparam.c</literal> for how to generate type D pairing
parameters.</simpara>

<simpara>Unfortunately currently the only way to determine the order of the curve group
and the order of the base field is to access internal fields of struct
cm_info_s. I hope to change this soon.</simpara>

<simpara>void  <emphasis role="strong">d_param_init</emphasis>(<emphasis>d_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>p</emphasis>. This must be called before <emphasis>p</emphasis> can be used.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">d_param_clear</emphasis>(<emphasis>d_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">d_param_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>d_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Write the parameters in <emphasis>p</emphasis> in a text format onto <emphasis>stream</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">d_param_from_cm</emphasis>(<emphasis>d_param_t p</emphasis>, <emphasis>cm_info_t cm</emphasis>)</simpara>

<blockquote>
<simpara>Type D curves are generated using the complex multiplication (CM) method.  This
function sets <emphasis>p</emphasis> to a type D pairing parameters from CM parameters <emphasis>cm</emphasis>.
Other library calls search for appropriate CM parameters and the results
can be passed to this function.</simpara>

<simpara>To be secure, generic discrete log algorithms must be infeasible in groups of
order r, and finite field discrete log algorithms must be infeasible in finite
fields of order q<superscript>6</superscript>.  For usual CM parameters, r is a few bits smaller than q.</simpara>

</blockquote>
<simpara>The <literal>cm_info_t</literal> data type holds CM parameters that are used
to generate curves.</simpara>

<simpara>void  <emphasis role="strong">cm_info_init</emphasis>(<emphasis>cm_info_t cm</emphasis>)</simpara>

<blockquote>
<simpara>Initializes <emphasis>cm</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">cm_info_clear</emphasis>(<emphasis>cm_info_t cm</emphasis>)</simpara>

<blockquote>
<simpara>Clears <emphasis>cm</emphasis>.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">find_mnt6_curve</emphasis>(<emphasis>void (<emphasis role="strong">callback)(cm_info_t</emphasis>, <emphasis>void </emphasis>)</emphasis>, <emphasis>void *data</emphasis>, <emphasis>unsigned int D</emphasis>, <emphasis>unsigned int bitlimit</emphasis>)</simpara>

<blockquote>
<simpara>For a given discriminant D, searches for MNT curves of embedding degree 6
suitable for cryptography (type D pairings) where the group order
is at most <emphasis>bitlimit</emphasis> bits. For each suitable set of CM parameters found,
call supplied callback with <literal>cm_info_t</literal> and given void pointer.
Returns the number of CM parameters found.</simpara>

</blockquote>
<simpara>int  <emphasis role="strong">find_freeman_curve</emphasis>(<emphasis>void (<emphasis role="strong">callback)(cm_info_t</emphasis>, <emphasis>void </emphasis>)</emphasis>, <emphasis>void *data</emphasis>, <emphasis>unsigned int D</emphasis>, <emphasis>unsigned int bitlimit</emphasis>)</simpara>

<blockquote>
<simpara>For a given discriminant D, searches for a Freeman curve of embedding
degree 10
suitable for cryptography (type D pairings) where the group order
is at most <emphasis>bitlimit</emphasis> bits. For each suitable set of CM parameters found,
call supplied callback with <literal>cm_info_t</literal> and given void pointer.
Returns the number of CM parameters found.</simpara>

</blockquote>
</section>
<section>
<title>Type E</title>
<simpara>This pairing is not very useful at present. It can be implemented entirely
in a field of prime order, that is, only arithmetic modulo a prime is needed
and there is never a need to extend a field.</simpara>

<simpara>If some day a mathematician discovers
that discrete log in field extensions is substantially
easier to solve than previously
thought, or finds that discrete log can be solved in elliptic curves
as easily as they can be in finite fields, this pairing type may become useful.</simpara>

<simpara>void  <emphasis role="strong">e_param_init</emphasis>(<emphasis>e_param_t ep</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>p</emphasis>. This must be called before <emphasis>p</emphasis> can be used.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">e_param_clear</emphasis>(<emphasis>e_param_t ep</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">e_param_gen</emphasis>(<emphasis>e_param_t p</emphasis>, <emphasis>int rbits</emphasis>, <emphasis>int qbits</emphasis>)</simpara>

<blockquote>
<simpara>Generate type E pairing parameters and store them in <emphasis>p</emphasis>,
where the group order r is <emphasis>rbits</emphasis> long, and the order of the base field q
is <emphasis>qbits</emphasis> long. To be secure, generic discrete log algorithms must
be infeasible in groups of order r, and finite field discrete log algorithms
must be infeasible in finite fields of order q.</simpara>

<simpara>Typical values: <emphasis>rbits</emphasis> = 160, <emphasis>qbits</emphasis> = 1024.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">e_param_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>e_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Write the parameters in <emphasis>p</emphasis> in a text format onto <emphasis>stream</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Type F</title>
<simpara>Type F should be used when the top priority is to minimize bandwidth (e.g.
short signatures). The pairing is slower than the other types.</simpara>

<simpara>If finite field discrete log algorithms improve further,
type D pairings will have to use larger fields, but type F can still remain
short, up to a point.</simpara>

<simpara>void  <emphasis role="strong">f_param_init</emphasis>(<emphasis>f_param_t fp</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>p</emphasis>. This must be called before <emphasis>p</emphasis> can be used.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">f_param_clear</emphasis>(<emphasis>f_param_t fp</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">f_param_gen</emphasis>(<emphasis>f_param_t fp</emphasis>, <emphasis>int bits</emphasis>)</simpara>

<blockquote>
<simpara>Generate type F pairing parameters and store them in <emphasis>p</emphasis>.
Both the group order r and the order of the base field q will be roughly
<emphasis>bits</emphasis>-bit numbers.
To be secure, generic discrete log algorithms must
be infeasible in groups of order r, and finite field discrete log algorithms
must be infeasible in finite fields of order q^12.
Typical value: <emphasis>bits</emphasis> = 160.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">f_param_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>f_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Write the parameters in <emphasis>p</emphasis> in a text format onto <emphasis>stream</emphasis>.</simpara>

</blockquote>
</section>
<section>
<title>Type G</title>
<simpara>Type G curves have embedding degree 10. They are quite slow at the moment
so for now type F is a better choice.</simpara>

<simpara>The file <literal>param/g149.param</literal> contains parameters for a
type G pairing with 149-bit group and field sizes.</simpara>

<simpara>The <literal>g_param_t</literal> data type holds parameters for a type G pairing.</simpara>

<simpara>void  <emphasis role="strong">g_param_init</emphasis>(<emphasis>g_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Initialize <emphasis>p</emphasis>. This must be called before <emphasis>p</emphasis> can be used.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">g_param_clear</emphasis>(<emphasis>g_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Clear <emphasis>p</emphasis>. This should be called after <emphasis>p</emphasis> is no longer needed.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">g_param_out_str</emphasis>(<emphasis>FILE *stream</emphasis>, <emphasis>g_param_t p</emphasis>)</simpara>

<blockquote>
<simpara>Write the parameters in <emphasis>p</emphasis> in a text format onto <emphasis>stream</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">g_param_from_cm</emphasis>(<emphasis>g_param_t p</emphasis>, <emphasis>cm_info_t cm</emphasis>)</simpara>

<blockquote>
<simpara>Type G curves are generated using the complex multiplication (CM) method.  This
function sets <emphasis>p</emphasis> to a type G pairing parameters from CM parameters <emphasis>cm</emphasis>.
Another part of the library searches for appropriate CM parameters (see below)
and the results can be passed to this function.</simpara>

<simpara>To be secure, generic discrete log algorithms must be infeasible in groups of
order r, and finite field discrete log algorithms must be infeasible in finite
fields of order q<superscript>6</superscript>.  For usual CM parameters, r is a few bits smaller than q.</simpara>

</blockquote>
</section>
</chapter>
<chapter>
<title>Randomness Functions</title>
<simpara>The first time PBC is asked to generate a random number,
the library will try to open the file <literal>/dev/urandom</literal> as a
source of random bits. If this fails, PBC falls back to a deterministic
random number generator (which is of course completely useless for
cryptography).</simpara>

<simpara>It is possible to change the file used for random bits. Also, explicitly
selecting the deterministic random number generator will
suppress the warning.</simpara>

<simpara>void  <emphasis role="strong">random_set_file</emphasis>(<emphasis>char *filename</emphasis>)</simpara>

<blockquote>
<simpara>Uses <emphasis>filename</emphasis> as a source of random bytes. For example,
on Linux one might use <literal>/dev/random</literal>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">random_set_deterministic</emphasis>(<emphasis>void</emphasis>)</simpara>

<blockquote>
<simpara>Use a determinstic random number generator.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pbc_mpz_random</emphasis>(<emphasis>mpz_t z</emphasis>, <emphasis>mpz_t limit</emphasis>)</simpara>

<blockquote>
<simpara>Use previously chosen random number generator to select
a random <emphasis>z</emphasis> that is less than <emphasis>limit</emphasis>.</simpara>

</blockquote>
<simpara>void  <emphasis role="strong">pbc_mpz_randomb</emphasis>(<emphasis>mpz_t z</emphasis>, <emphasis>unsigned int bits</emphasis>)</simpara>

<blockquote>
<simpara>Use previously chosen random number generator to select
a random <emphasis>bits</emphasis>-bit integer <emphasis>z</emphasis>.</simpara>

</blockquote>
</chapter>
<chapter>
<title>Custom Allocation</title>
<simpara>Like GMP, PBC can be instructed to use custom memory allocation functions.
This must be done before any memory allocation is performed,
usually at the beginning of a program before any other PBC functions have
been called.</simpara>

<simpara>Also like GMP, the PBC wrappers around <literal>malloc</literal>
and <literal>realloc</literal> will print a message on standard error
and terminate program execution if the calls fail.
Replacements for these functions should act similarly.</simpara>

<simpara>However, unlike GMP, PBC does not pass the number of bytes previously allocated
along with the pointer in calls to <literal>realloc</literal> and
<literal>free</literal>.</simpara>

<simpara>void  <emphasis role="strong">pbc_set_memory_functions</emphasis>(<emphasis>void <emphasis role="strong">(*malloc_fn)(size_t)</emphasis>, <emphasis>        void </emphasis>(<emphasis role="strong">realloc_fn)(void </emphasis></emphasis>, <emphasis>size_t)</emphasis>, <emphasis>void (<emphasis role="strong">free_fn)(void </emphasis>)</emphasis>)</simpara>

<blockquote>
<simpara>Set custom allocation functions.  The parameters must be function pointers to
drop-in replacements for malloc, realloc and free, except that malloc and
realloc should terminate the program on failure: they must not return in this
case.</simpara>

</blockquote>
</chapter>
<chapter>
<title>Bundled Programs</title>
<simpara>Several binaries and curve parameters are bundled with the PBC library,
such as <link linkend="pbcintro">the <literal>pbc</literal> program</link>.</simpara>

<simpara>The <literal>param</literal> subdirectory contains pairing parameters one might use in
a real cryptosystem. Many of the test programs read the parameters
from files such as these on standard input, for example:</simpara>

<literallayout class="monospaced">$ benchmark/benchmark &lt; param/c159.param
$ example/bls &lt; param/e.param</literallayout>
<section id="pbcref">
<title>Pairing-Based Calculator</title>
<simpara>The <literal>pbc</literal> subdirectory contains a program also named
<literal>pbc</literal> which allows interactive testing of the PBC library.</simpara>

<simpara>Its syntax is loosely based on that of <literal>bc</literal>, a well-known arbitrary precision
calculator language. I do not intend for <literal>pbc</literal> to be a fully-fledged scripting
language. If this were the aim I would add a module to an extant popular
language.  Instead, pbc is meant to be a test program.  (Nonetheless, it
possesses enough functionality to be used to implement cryptosystems in shell
scripts.)</simpara>

<simpara>Four pairings named A, D, E and F are initialized during startup, and
furthermore, the variables G1, G2, GT and Zr are setup to represent groups
associated with the A pairing. To use a different pairing, call the
init_pairing funciton.</simpara>

<simpara>Assignments have a C-like syntax "variable = expression", and return the value
of the variable.  Function calls and expressions also resemble C.  The
arithmetic operators +, -, /, *, ^ have the standard precedence.  Perhaps the
only significant difference is that no terminating semicolon is required.</simpara>

<simpara>Comments begin with "#" and end at a newline.  Double quotes are used to denote
strings.  On error, pbc prints the error code which I have yet to translate to
English.</simpara>

<simpara>Some of the pbc functions:</simpara>

<variablelist>
<varlistentry>
<term>
<literal>init_pairing(pairing)</literal>
</term>
<listitem>
<simpara>
Set the variables G1, G2, GT and Zr to the groups in <literal>pairing</literal>, e.g:
</simpara>
<literallayout class="monospaced">init_pairing(D)</literallayout>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>rnd(G)</literal>
</term>
<listitem>
<simpara>
Returns a random element of the group G, e.g:
</simpara>
<literallayout class="monospaced">g = rnd(Zr)</literallayout>
<simpara>Has synonyms <literal>rand</literal> and <literal>random</literal>.</simpara>

</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>pairing(g, h)</literal>
</term>
<listitem>
<simpara>
Returns the pairing applied to <literal>g</literal> and <literal>h</literal>.
The element <literal>g</literal> must be an element of G1 and <literal>h</literal> of G2, e.g:
</simpara>
<literallayout class="monospaced">pairing(rnd(G1), rnd(G2))</literallayout>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>fromstr(string, G)</literal>
</term>
<listitem>
<simpara>
Returns <literal>string</literal> converted to an element of <literal>G</literal>, e.g.
</simpara>
<literallayout class="monospaced">x = fromstr("[123,456]", GT)</literallayout>
</listitem>
</varlistentry>
</variablelist>
</section>
<section>
<title>Parameter Generation</title>
<simpara>Programs that generate pairing parameters are located in the <literal>gen</literal>
subdirectory. Some of the programs are already functional enough to be used to
find parameters for real applications.  I need to write more documentation
first; for now, read the source!</simpara>

<variablelist>
<varlistentry>
<term>
<emphasis role="strong">listmnt</emphasis>
</term>
<listitem>
<simpara>
  Searches for discriminants D that lead to MNT curves with subgroups
  of prime order.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">genaparam</emphasis>, <emphasis role="strong">gena1param</emphasis>, <emphasis role="strong">gendparam</emphasis>, <emphasis role="strong">geneparam</emphasis>, <emphasis role="strong">genfparam</emphasis>
</term>
<listitem>
<simpara>
  Prints parameters for a curve suitable for computing pairings of a given type.
  The output can be fed to some of the other test programs.  The program
  <literal>gendparam</literal> should be given a discriminant as the first argument.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">hilbertpoly</emphasis>
</term>
<listitem>
<simpara>
  Prints the Hilbert polynomial for a given discriminant (the first argument).
  Computing the Hilbert polynomial is an intermediate step when generating
  type D parameters.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section>
<title>Example Cryptosystems</title>
<simpara>In the <literal>example</literal> subdirectory there are various programs that read curve
parameters on standard input and perform computations that would be required in
a typical implementation of a pairing-based cryptosystem. Sample schemes
include:</simpara>

<itemizedlist>
<listitem>
<simpara>
Boneh-Lynn-Shacham short signatures
</simpara>
</listitem>
<listitem>
<simpara>
Hess identity-based signatures
</simpara>
</listitem>
<listitem>
<simpara>
Joux tripartite Diffie-Hellman
</simpara>
</listitem>
<listitem>
<simpara>
Paterson identity-based signatures
</simpara>
</listitem>
<listitem>
<simpara>
Yuan-Li identity-based authenticated key agreement
</simpara>
</listitem>
<listitem>
<simpara>
Zhang-Kim identity-based blind/ring signatures
</simpara>
</listitem>
<listitem>
<simpara>
Zhang-Safavi-Naini-Susilo signatures
</simpara>
</listitem>
</itemizedlist>
<simpara>More work would be required to turn these programs into real applications.</simpara>

</section>
<section>
<title>Benchmarks</title>
<simpara>I use the programs in the <literal>benchmark</literal> subdirectory to measure running times of
pairings, and also RSA decryptions.</simpara>

<simpara>The <literal>benchmark</literal> program takes pairing parameters on standard input and reports
the average running time of the pairing over 10 runs, while <literal>timersa</literal> estimates
the time required to perform one 1024-bit RSA decryption.</simpara>

</section>
</chapter>
<chapter>
<title>PBC Internals</title>
<simpara>Algebraic structures are represented in the <literal>field_t</literal> data type, which mostly
contains pointers to functions written to perform operations such as addition
and multiplication on elements of that particular group, ring or field:</simpara>

<literallayout class="monospaced">struct field_s {
  ...
  void (*init)(element_ptr);
  void (*clear)(element_ptr);
  ...
  void (*add)(element_ptr, element_ptr, element_ptr);
  void (*sub)(element_ptr, element_ptr, element_ptr);
  void (*mul)(element_ptr, element_ptr, element_ptr);
  ...
};
typedef struct field_s *field_ptr;
typedef struct field_s field_t[1];</literallayout>
<simpara>The name <literal>algebraic_structure_t</literal> is arguably more accurate, but far too
cumbersome.  It may help if one views groups and rings as handicapped fields.</simpara>

<simpara>The last two lines of the above code excerpt show how GMP and PBC define data
types: they are arrays of length one so that when a variable is
declared, space is automatically allocated for it.  Yet when used as a argument
to a function, a pointer is passed, thus there is no need to explicitly
allocate and deallocate memory, nor reference and dereference variables.</simpara>

<simpara>Each <literal>element_t</literal> contains a field named <literal>field</literal> to such a <literal>field_t</literal> variable.
The only other field is <literal>data</literal>, which stores any data needed for the
implementation of the particular algebraic structure the element resides in.</simpara>

<literallayout class="monospaced">struct element_s {
    struct field_s *field;
    void *data;
};</literallayout>
<simpara>When an <literal>element_t</literal> variable is initialized, <literal>field</literal> is set appropriately, and
then the initialization specific to that field is called to complete the
initialization. Here, a line of code is worth a thousand words:</simpara>

<literallayout class="monospaced">void element_init(element_t e, field_ptr f)
{
    e-&gt;field = f;
    f-&gt;init(e);
}</literallayout>
<simpara>Thus when a call to one of the <literal>element_</literal> functions, the <literal>field</literal> pointer is
followed to see which version of the function should be called, so that for
example modular addition is performed if the input element is an element of a
finite field, while polynomial addition is performed for elements of a
polynomial ring and so on.</simpara>

<literallayout class="monospaced">void element_add(element_t n, element_t a, element_t b)
{
    n-&gt;field-&gt;add(n, a, b);
}</literallayout>
<section>
<title>Design</title>
<simpara>My design may seem dangerous because if a programmer inadvertently attempts
to add a polynomial and a point on an elliptic curve, say, the code
will compile without warnings since they have the same data type,
but the results are undefined and the library will mostly cause a crash.</simpara>

<simpara>However I settled on having a catch-all &#8220;glorified <literal>void *</literal>&#8221; <literal>element_t</literal>
because I wanted to</simpara>

<itemizedlist>
<listitem>
<simpara>
extend a field an arbitrary number of times (though in practice, currently I
  only need to extend a field twice at most),
</simpara>
</listitem>
<listitem>
<simpara>
switch fields easily, so for example a program that benchmarks addition in
  polynomial rings can be trivially modified to benchmark addition in a group,
  and
</simpara>
</listitem>
<listitem>
<simpara>
interchange different implementations of the same algebraic structure, for
  example, when I was comparing Montgomery representation versus a naive
  implementation of modular arithmetic.
</simpara>
</listitem>
</itemizedlist>
<simpara>I could have separate data types to distinguish between groups, rings and
fields. It is important to label them differently in mathematics, but here it
makes more sense to lump them together under the same heading, and just treat
some kinds as handicapped.  Distinct data types may lead to a false sense of
security.  For example, fields of prime order with different moduli would still
fall under the same data type, with unpleasant results if their elements are
mistakenly mixed.</simpara>

<simpara>I have vague plans to add flags to <literal>field_t</literal> describing the capabilities of a
particular <literal>field_t</literal>.  These flags would be set during initialization, and
would indicate for example whether one can invert every nonzero element,
whether there are one or two operations (that is, group versus ring), whether
the field is an integer mod ring, polynomial ring, or polynomial mod ring, and
so on. Once in place, more runtime checks can be performed to avoid illegal
inversion and similar problems.</simpara>

<simpara>Another option is to introduce data types for each of the four pairing-related
algebraic structures, namely G1, G2, GT and Zr, as these are the only ones
needed for implementing pairing-based cryptosystems.</simpara>

<simpara>An alternative was to simply use <literal>void *</literal> instead of <literal>element_t</literal> and require
the programmer to pass the field as a parameter, e.g. <literal>element_add(a, b, c,
F_13)</literal>, but I decided the added annoyance of having to type this extra variable
every time negated any benefits, such as obviating the need for the
<literal>field</literal> pointer in <literal>struct element_s</literal>, even if one ignores
the more serious problem that runtime type checking is considerably harder, if
not impossible.</simpara>

<simpara>I suppose one could write a preprocessor to convert one type of notation
to the other, but I would like the code to be standard C.  (On the other hand,
as Hovav Shacham suggested, it may be nice to eventually have a converter that
takes human-friendly infix operator expressions like <literal>a = (b + c) *
d</literal> and outputs the assembly-like <literal>element_</literal> equivalents.)</simpara>

<simpara>The
<ulink url="http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html">GNU libc manual</ulink>
states that data types ending in <literal>_t</literal> should not be used because they are
reserved for future additions to C or POSIX.  On the other hand, I want to stay
consistent with GMP, and I hear ending data types with <literal>_t</literal> is common practice.</simpara>

</section>
<section>
<title>Internal Randomness</title>
<simpara>Some algorithms require a quadratic nonresidue in a given field. The first
time a quadratic nonresidue is requested, one is generated at random, using
the same source of random bits as other PBC random functions. [Which
reminds me, should I get rid of the <literal>nqr</literal> field and
instead have it as part of the <literal>data</literal> field in
struct field_s?]</simpara>

<simpara>In <literal>fieldquadratic.c</literal>, a quadratic field extension is constructed with a square
root of this randomly generated quadratic nonresidue in the base field.  Thus
for a nondeterminstic source of random bits, the same field may be constructed
  differently on different runs.</simpara>

<simpara>To construct the same field the same way every time, one must record the
quadratic nonresidue generated from one run, and call <literal>field_set_nqr()</literal> every
time this particular construction of a quadratic field extension is desired.
Another use for this function is to save time by setting the quadratic
nonresidue to some precomputed value.</simpara>

<simpara>Similarly, for higher degree extensions, a random irreducible polynomial
may be chosen to construct it, but this must be recorded if the same
construction is later required.</simpara>

<simpara>This happens behind the scenes in PBC.</simpara>

</section>
<section>
<title>Type A Internals</title>
<simpara>Type A pairings are constructed on the curve y<superscript>2</superscript> = x<superscript>3</superscript> + x over the field F_q
for some prime q.  Both G1 and G2 are the group of points E(F_q), so this
pairing is symmetric.  It turns out #E(F_q) = q + 1 and
#E(F_q<superscript>2</superscript>) = (q + 1)<superscript>2</superscript>. Thus the embedding degree k is 2,
and hence GT is a subgroup of F_q^2.  The order r is some prime
factor of q + 1.</simpara>

<simpara>Write q + 1 = r * h. For efficiency, r is picked to be a Solinas prime,
that is, r has the form 2<superscript>a</superscript> +- 2<superscript>b</superscript> +- 1 for some integers 0 &lt; b &lt; a.</simpara>

<simpara>Also, q = -1 mod 12 so F_q<superscript>2</superscript> can be implemented as F_q[i]
(where i = sqrt(-1)) and since q = -1 mod 3, cube roots in F_q
are easy to compute. This latter feature may be removed because I have
not found a use for it yet (in which case we only need q = -1 mod 4).</simpara>

<simpara><literal>a_param</literal> struct fields:</simpara>

<literallayout class="monospaced">exp2, exp1, sign1, sign0, r:
  r = 2^exp2 + sign1 * 2^exp1 + sign0 * 1 (Solinas prime)
q, h:
  r * h = q + 1
  q is a prime, h is a multiple of 12 (thus q = -1 mod 12)</literallayout>
</section>
<section>
<title>Type D Internals</title>
<simpara>These are ordinary curves of with embedding degree 6, whose orders are prime
or a prime multiplied by a small constant. These are constructed using the
method due to MNT.</simpara>

<simpara>A type D curve is defined over some field F_q and has order h * r where
r is a prime and h is a small constant. Over the field F_q<superscript>6</superscript> its order is
a multiple of r<superscript>2</superscript>.</simpara>

<simpara>Typically the order of the curve E is around 170 bits, as is F_q, the base
field, thus q<superscript>k</superscript> is around the 1024-bit mark which is commonly considered
good enough.</simpara>

<literallayout class="monospaced">c_param struct fields:
q   F_q is the base field
n   # of points in E(F_q)
r   large prime dividing n
h   n = h * r
a   E is given by y^2 = x^3 + ax + b
b
nk  # of points in E(F_q^k)
hk  nk = hk * r * r</literallayout>
</section>
<section>
<title>Type E Internals</title>
<simpara>The CM (Complex Multiplication) method of constructing elliptic curves
starts with the Diophantine equation</simpara>

<literallayout class="monospaced">DV^2 = 4q - t^2</literallayout>
<simpara>If t = 2 and q = D r<superscript>2</superscript> h<superscript>2</superscript> + 1 for some prime r (which we choose to
be a Solinas prime) and some integer h, we find that this equation is easily
solved with V = 2rh.</simpara>

<simpara>Thus it is easy to find a curve (over the field F_q) with order q - 1.
Note r<superscript>2</superscript> divides q - 1, thus we have an embedding degree of 1.</simpara>

<simpara>Hence all computations necessary for the pairing can be done in F_q alone.
There is never any need to extend F_q.</simpara>

<simpara>As q is typically 1024 bits, group elements take a lot of space to represent.
Moreover, many optimizations do not apply to this type, resulting in a slower
pairing.</simpara>

<simpara>TODO: describe fields</simpara>

</section>
<section>
<title>Type F Internals</title>
<simpara>Using carefully crafted polynomials, k = 12 pairings can be constructed.
Only 160 bits are needed to represent elements of one group, and 320 bits
for the other.</simpara>

<simpara>Also, embedding degree k = 12 allows higher security short signatures.
(k = 6 curves cannot
be used to scale security from 160-bits to say 256-bits because finite
field attacks are subexponential.)</simpara>

<simpara>TODO: describe fields</simpara>

</section>
<section>
<title>Source Code</title>
<simpara>The source code is organized into several subdirectories.</simpara>

<simpara>All include files are in the <literal>include</literal> directory.</simpara>

<simpara>The <literal>arith</literal> directory contains code for implementing
finite fields of any characteristic greater than 3:
modular arithmetic, polynomial rings, and finally polynomial
rings modulo a polynomial. In future, finite fields of
low characteristic may be implemented.</simpara>

<simpara>The <literal>ecc</literal> directory contains code for arbitrary
precision complex numbers, curve generation (which depends on the former),
curve group operations and pairings. A separate source file is dedicated
to each type of pairing, containing optimizations tailored for
its pairing.</simpara>

<simpara>The <literal>misc</literal> directory contains code for dynamic arrays,
symbol tables, parsing, benchmarking, debugging and so on.</simpara>

<simpara>The <literal>test</literal> directory contains test programs. They
were used to generate the files in the <literal>param</literal> directory.</simpara>

</section>
<section>
<title>Religious Stances</title>
<simpara>I chose C because:</simpara>

<itemizedlist>
<listitem>
<simpara>
GMP, which PBC requires and is also modeled on, is also written in C.
</simpara>
</listitem>
<listitem>
<simpara>
PBC is intended to be a low-level portable cryptographic library.  C is the
  least common denominator. It should not be difficult to wrap PBC for other
  languages.
</simpara>
</listitem>
<listitem>
<simpara>
Despite its drawbacks (I could really use operator overloading and
  genericity, and to a lesser extent garbage collection), I've found few
  languages I like better.  To quote Rob Pike, C is the desert island language.
  (I also agree with his statement that OO languages conceptually provide
  little extra over judicious use of function pointers in C.)
</simpara>
</listitem>
</itemizedlist>
<simpara>I use the One True Brace Style.</simpara>

<simpara>I'd like to have no library dependencies (except standard C libraries),
but then I'd have to write a large integer library. Not only that, it'd
have to be in assembly, and then I'd need to port it. To avoid this,
I use an existing library instead.</simpara>

<simpara>I selected GMP because the library's focus is on multiprecision arithmetic and
nothing else, and it aims to be as fast as possible on many platforms.  Another
important factor is that GMP is released under a free license.</simpara>

<simpara>On the other hand, GMP is written to deal with extremely large numbers, while I
mostly only need integers that are roughly between 160 and 2048 bits. It is
possible a library specializing in numbers of these sizes would be better for
PBC.</simpara>

<simpara>I'm fond of GMP's method for eliminating the need for the <literal>&amp;amp;</literal> and <literal>*</literal>
operators most of the time by declaring a typedef on arrays of size 1.  I try
to do the same with PBC for consistency, though this trick does have drawbacks.</simpara>

<simpara>I would like to have GMP as the only library dependency, though I do not mind
using other libraries so long as they are optional. For example, one of the
test programs is much easier to use if compiled with the GNU readline library,
but by default compiles without it and is still functional.</simpara>

<simpara>I dislike the C preprocessor. I like to place platform-specific code in
separate files and let the build system work out which one to use.  Integer
constants can be defined with enum instead.  I intend to minimize the number of
<literal>#include</literal> statements in header files for PBC's internal use as much as
possible (they should be in the <literal>.c</literal> files instead), and later perhaps even
remove those annoying <literal>#ifndef</literal> statements too.</simpara>

<simpara>Unfortunately I do not know of an easy way to avoid the C preprocessor
for PBC's debugging features.</simpara>

</section>
</chapter>
<chapter>
<title>Security Issues</title>
<simpara>We list potential security issues.</simpara>

<section>
<title>Truncated Hashes</title>
<simpara>For points on an elliptic curve over the base field, <literal>element_from_hash()</literal> will
truncate the input hash until it can represent an x-coordinate in that field.
(PBC then computes a corresponding y-coordinate.) Ideally the hash length
should be smaller than size of the base field and also the size of the elliptic
curve group.</simpara>

<simpara>Hashing to elements in field extensions does not take advantage of the fact
that the extension has more elements than the base field. I intend to rewrite
the code so that for a degree n extension code, PBC splits the hash into n parts
and determine each polynomial coefficient from one ofthe pieces.
At the moment every coefficient is the same and depends on the whole hash.</simpara>

<simpara>This is harmless for the base field, because all the pairing types implemented
so far use an integer mod ring as the base field, rather than an extension of
some low characteristic field.</simpara>

</section>
<section>
<title>Zeroed Memory</title>
<simpara>Unlike OpenSSL, there are no functions to zero memory locations used in
sensitive computations. To some extent, one can use <literal>element_random()</literal> to
overwrite data.  I have no immediate plans to implement this, but could be
convinced to do so if I hear enough reasons.</simpara>

</section>
<section>
<title>PRNG Determinism</title>
<simpara>On platforms without <literal>/dev/urandom</literal> PBC falls back on a deterministic
pseudo-random number generator.</simpara>

<simpara>Also, <literal>/dev/urandom</literal> differs from <literal>/dev/random</literal>, the device of choice for the
paranoid. A quote from its manpage:</simpara>

<blockquote>
<simpara>A  read  from  the  /dev/urandom device will not block waiting for more
entropy.  As a result, if  there  is  not  sufficient  entropy  in  the
entropy  pool,  the  returned  values are theoretically vulnerable to a
cryptographic attack on the algorithms used by the  driver.   Knowledge
of how to do this is not available in the current non-classified literature,
but it is theoretically possible that such an attack may  exist.
If this is a concern in your application, use /dev/random instead.</simpara>

</blockquote>
</section>
</chapter>
<appendix>
<title>Contributors</title>
<simpara>Ben Lynn wrote the original PBC library and documentation and is still
maintaining and developing it.</simpara>

<simpara>Hovav Shacham wrote the multiexponentiation, sliding windows and preprocessed
exponentiation routines, Makefile improvements, and other enhancements.
He also helps administer the mailing list.</simpara>

<simpara>Joseph Cooley wrote the GNU build system files,
tested the library on Mac OS X, and added miscellaneous improvements.
Among other things,
pairings can be read from memory buffer and
most compile-time warnings were removed.</simpara>

<simpara>Rob Figueiredo and Roger Khazan wrote changes which allow the PBC library
to be compiled on Windows (via mingw).</simpara>

<simpara>Dmitry Kosolapov sent in manual corrections, and wrote
several cryptosystem demos.</simpara>

<simpara>John Bethencourt sent in many helpful patches, e.g. fixes that allow PBC to
work on 64-bit platforms.</simpara>

<simpara>Paul Miller reported bugs, manual corrections and also wrote
the Gentoo portage overlay for PBC.</simpara>

<simpara>If you're not mentioned here but should be, please let me know!
(blynn at cs dot stanford dot edu).</simpara>

</appendix>
</book>
